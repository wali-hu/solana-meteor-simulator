"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const idl_1 = require("./idl");
const affiliate_idl_1 = require("./affiliate-idl");
const helper_1 = require("./helper");
const vault_1 = __importDefault(require("./strategy/vault"));
const getAllVaultState = (tokensAddress, program, seedBaseKey) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultAccountPdas = tokensAddress.map((tokenMint) => (0, utils_1.getVaultPdas)(tokenMint, new web3_js_1.PublicKey(program.programId), seedBaseKey));
    const vaultsPda = vaultAccountPdas.map(({ vaultPda }) => vaultPda);
    const vaultsState = (yield (0, utils_1.chunkedFetchMultipleVaultAccount)(program, vaultsPda));
    if (vaultsState.length !== tokensAddress.length) {
        throw new Error('Some of the vault state cannot be fetched');
    }
    const vaultLpMints = vaultsState.map((vaultState) => vaultState.lpMint);
    const vaultMints = vaultsState.map((vaultState) => vaultState.tokenMint);
    const vaultLpAccounts = yield (0, utils_1.chunkedGetMultipleAccountInfos)(program.provider.connection, [
        ...vaultLpMints,
        ...vaultMints,
    ]);
    return vaultsState.map((vaultState, index) => {
        const vaultAccountPda = vaultAccountPdas[index];
        if (!vaultAccountPda)
            throw new Error('Missing vault account pda');
        const vaultLpAccount = vaultLpAccounts[index];
        if (!vaultLpAccount)
            throw new Error('Missing vault lp account');
        const vaultLpMint = (0, spl_token_1.unpackMint)(vaultState.lpMint, vaultLpAccount, vaultLpAccount.owner);
        const vaultAccount = vaultLpAccounts[index + vaultLpMints.length];
        if (!vaultAccount)
            throw new Error('Missing vault account');
        const vaultMint = (0, spl_token_1.unpackMint)(vaultState.tokenMint, vaultAccount, vaultAccount.owner);
        return { vaultPda: vaultAccountPda.vaultPda, vaultState, vaultMint, vaultLpMint };
    });
});
const getAllVaultStateByPda = (vaultsPda, program) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultsState = (yield (0, utils_1.chunkedFetchMultipleVaultAccount)(program, vaultsPda));
    if (vaultsState.length !== vaultsPda.length) {
        throw new Error('Some of the vault state cannot be fetched');
    }
    const vaultLpMints = vaultsState.map((vaultState) => vaultState.lpMint);
    const vaultMints = vaultsState.map((vaultState) => vaultState.tokenMint);
    const vaultLpAccounts = yield (0, utils_1.chunkedGetMultipleAccountInfos)(program.provider.connection, [
        ...vaultLpMints,
        ...vaultMints,
    ]);
    return vaultsState.map((vaultState, index) => {
        const vaultPda = vaultsPda[index];
        if (!vaultPda)
            throw new Error('Missing vault account pda');
        const vaultLpAccount = vaultLpAccounts[index];
        if (!vaultLpAccount)
            throw new Error('Missing vault lp account');
        const vaultLpMint = (0, spl_token_1.unpackMint)(vaultState.lpMint, vaultLpAccount, vaultLpAccount.owner);
        const vaultAccount = vaultLpAccounts[index + vaultLpMints.length];
        if (!vaultAccount)
            throw new Error('Missing vault account');
        const vaultMint = (0, spl_token_1.unpackMint)(vaultState.tokenMint, vaultAccount, vaultAccount.owner);
        return {
            vaultPda,
            vaultState,
            vaultLpMint,
            vaultMint,
        };
    });
});
const getVaultState = (tokenAddress, program, seedBaseKey) => __awaiter(void 0, void 0, void 0, function* () {
    const { vaultPda } = (0, utils_1.getVaultPdas)(tokenAddress, new web3_js_1.PublicKey(program.programId), seedBaseKey);
    const vaultState = (yield program.account.vault.fetchNullable(vaultPda));
    if (!vaultState) {
        throw 'Cannot get vault state';
    }
    const [vaultLpAccount, vaultAccount] = yield (0, utils_1.chunkedGetMultipleAccountInfos)(program.provider.connection, [
        vaultState.lpMint,
        vaultState.tokenMint,
    ]);
    const vaultLpMint = (0, spl_token_1.unpackMint)(vaultState.lpMint, vaultLpAccount, vaultLpAccount === null || vaultLpAccount === void 0 ? void 0 : vaultLpAccount.owner);
    const vaultMint = (0, spl_token_1.unpackMint)(vaultState.tokenMint, vaultAccount, vaultAccount === null || vaultAccount === void 0 ? void 0 : vaultAccount.owner);
    return {
        vaultPda,
        vaultState,
        vaultLpMint,
        vaultMint,
    };
});
const getVaultStateByPda = (vaultPda, program) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultState = (yield program.account.vault.fetchNullable(vaultPda));
    if (!vaultState) {
        throw 'Cannot get vault state';
    }
    const [vaultLpAccount, vaultAccount] = yield (0, utils_1.chunkedGetMultipleAccountInfos)(program.provider.connection, [
        vaultState.lpMint,
        vaultState.tokenMint,
    ]);
    const vaultLpMint = (0, spl_token_1.unpackMint)(vaultState.lpMint, vaultLpAccount, vaultLpAccount === null || vaultLpAccount === void 0 ? void 0 : vaultLpAccount.owner);
    const vaultMint = (0, spl_token_1.unpackMint)(vaultState.tokenMint, vaultAccount, vaultAccount === null || vaultAccount === void 0 ? void 0 : vaultAccount.owner);
    return {
        vaultPda,
        vaultState,
        vaultLpMint,
        vaultMint,
    };
});
const getVaultLiquidity = (connection, tokenVaultPda) => __awaiter(void 0, void 0, void 0, function* () {
    const vaultLiquidityResponse = yield connection.getAccountInfo(tokenVaultPda);
    if (!vaultLiquidityResponse)
        return null;
    const vaultLiquiditySerialize = (0, utils_1.deserializeAccount)(vaultLiquidityResponse.data);
    return (vaultLiquiditySerialize === null || vaultLiquiditySerialize === void 0 ? void 0 : vaultLiquiditySerialize.amount.toString()) || null;
});
class VaultImpl {
    constructor(program, vaultDetails, opt) {
        var _a;
        this.cluster = 'mainnet-beta';
        this.connection = program.provider.connection;
        this.cluster = (_a = opt === null || opt === void 0 ? void 0 : opt.cluster) !== null && _a !== void 0 ? _a : 'mainnet-beta';
        this.program = program;
        this.affiliateProgram = opt === null || opt === void 0 ? void 0 : opt.affiliateProgram;
        this.affiliateId = opt === null || opt === void 0 ? void 0 : opt.affiliateId;
        this.allowOwnerOffCurve = opt === null || opt === void 0 ? void 0 : opt.allowOwnerOffCurve;
        this.tokenLpMint = vaultDetails.vaultLpMint;
        this.tokenMint = vaultDetails.vaultMint;
        this.vaultPda = vaultDetails.vaultPda;
        this.tokenVaultPda = vaultDetails.tokenVaultPda;
        this.vaultState = vaultDetails.vaultState;
    }
    static createPermissionlessVaultInstruction(connection, payer, tokenMint, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new anchor_1.AnchorProvider(connection, {}, anchor_1.AnchorProvider.defaultOptions());
            const program = new anchor_1.Program(idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || constants_1.PROGRAM_ID, provider);
            const { vaultPda: vault, tokenVaultPda: tokenVault, lpMintPda: lpMint, } = (0, utils_1.getVaultPdas)(tokenMint, program.programId);
            return program.methods
                .initialize()
                .accounts({
                vault,
                payer,
                tokenVault,
                tokenMint,
                lpMint,
                systemProgram: web3_js_1.SystemProgram.programId,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            })
                .instruction();
        });
    }
    static fetchMultipleUserBalance(connection, lpMintList, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const ataAccounts = lpMintList.map((lpMint) => (0, utils_1.getAssociatedTokenAccount)(lpMint, owner));
            const accountsInfo = yield (0, utils_1.chunkedGetMultipleAccountInfos)(connection, ataAccounts);
            return accountsInfo.map((accountInfo) => {
                if (!accountInfo)
                    return new anchor_1.BN(0);
                const accountBalance = (0, utils_1.deserializeAccount)(accountInfo.data);
                if (!accountBalance)
                    throw new Error('Failed to parse user account for LP token.');
                return new anchor_1.BN(accountBalance.amount.toString());
            });
        });
    }
    static createMultiple(connection, tokenMints, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new anchor_1.AnchorProvider(connection, {}, anchor_1.AnchorProvider.defaultOptions());
            const program = new anchor_1.Program(idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || constants_1.PROGRAM_ID, provider);
            const vaultsStateInfo = yield getAllVaultState(tokenMints, program);
            return Promise.all(vaultsStateInfo.map((_a) => __awaiter(this, [_a], void 0, function* ({ vaultPda, vaultState, vaultLpMint, vaultMint }) {
                return new VaultImpl(program, {
                    vaultPda,
                    tokenVaultPda: vaultState.tokenVault,
                    vaultState,
                    vaultLpMint,
                    vaultMint,
                }, Object.assign(Object.assign({}, opt), { affiliateId: opt === null || opt === void 0 ? void 0 : opt.affiliateId, affiliateProgram: (opt === null || opt === void 0 ? void 0 : opt.affiliateId)
                        ? new anchor_1.Program(affiliate_idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.affiliateProgramId) || constants_1.AFFILIATE_PROGRAM_ID, provider)
                        : undefined }));
            })));
        });
    }
    static createMultipleWithPda(connection, vaultsPda, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new anchor_1.AnchorProvider(connection, {}, anchor_1.AnchorProvider.defaultOptions());
            const program = new anchor_1.Program(idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || constants_1.PROGRAM_ID, provider);
            const vaultsStateInfo = yield getAllVaultStateByPda(vaultsPda, program);
            return Promise.all(vaultsStateInfo.map((_a) => __awaiter(this, [_a], void 0, function* ({ vaultPda, vaultState, vaultMint, vaultLpMint }) {
                return new VaultImpl(program, {
                    vaultPda,
                    tokenVaultPda: vaultState.tokenVault,
                    vaultState,
                    vaultMint,
                    vaultLpMint,
                }, Object.assign(Object.assign({}, opt), { affiliateId: opt === null || opt === void 0 ? void 0 : opt.affiliateId, affiliateProgram: (opt === null || opt === void 0 ? void 0 : opt.affiliateId)
                        ? new anchor_1.Program(affiliate_idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.affiliateProgramId) || constants_1.AFFILIATE_PROGRAM_ID, provider)
                        : undefined }));
            })));
        });
    }
    static create(connection, tokenAddress, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = new anchor_1.AnchorProvider(connection, {}, anchor_1.AnchorProvider.defaultOptions());
            const program = new anchor_1.Program(idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.programId) || constants_1.PROGRAM_ID, provider);
            const { vaultPda, vaultState, vaultMint, vaultLpMint } = yield getVaultState(tokenAddress, program);
            return new VaultImpl(program, {
                vaultMint,
                vaultLpMint,
                vaultPda,
                tokenVaultPda: vaultState.tokenVault,
                vaultState,
            }, Object.assign(Object.assign({}, opt), { affiliateId: opt === null || opt === void 0 ? void 0 : opt.affiliateId, affiliateProgram: (opt === null || opt === void 0 ? void 0 : opt.affiliateId)
                    ? new anchor_1.Program(affiliate_idl_1.IDL, (opt === null || opt === void 0 ? void 0 : opt.affiliateProgramId) || constants_1.AFFILIATE_PROGRAM_ID, provider)
                    : undefined }));
        });
    }
    getUserBalance(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const isAffiliated = this.affiliateId && this.affiliateProgram;
            const address = yield (() => __awaiter(this, void 0, void 0, function* () {
                // User deposit directly
                if (!isAffiliated) {
                    return (0, utils_1.getAssociatedTokenAccount)(this.vaultState.lpMint, owner);
                }
                // Get user affiliated address with the partner
                const { userLpToken } = yield this.createAffiliateATAPreInstructions(owner);
                return userLpToken;
            }))();
            const accountInfo = yield this.connection.getAccountInfo(address);
            if (!accountInfo) {
                return new anchor_1.BN(0);
            }
            const result = (0, utils_1.deserializeAccount)(accountInfo.data);
            if (result == undefined) {
                throw new Error('Failed to parse user account for LP token.');
            }
            return new anchor_1.BN(result.amount.toString());
        });
    }
    /** To refetch the latest lpSupply */
    /** Use vaultImpl.lpSupply to use cached result */
    getVaultSupply() {
        return __awaiter(this, void 0, void 0, function* () {
            const vaultLpMint = yield (0, spl_token_1.getMint)(this.connection, this.vaultState.lpMint);
            this.tokenLpMint = vaultLpMint;
            return new anchor_1.BN(vaultLpMint.supply.toString());
        });
    }
    getWithdrawableAmount() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTime = yield (0, utils_1.getOnchainTime)(this.connection);
            return (0, helper_1.calculateWithdrawableAmount)(currentTime, this.vaultState);
        });
    }
    refreshVaultState() {
        return __awaiter(this, void 0, void 0, function* () {
            const { vaultState, vaultMint } = yield getVaultStateByPda(this.vaultPda, this.program);
            this.vaultState = vaultState;
            this.tokenMint = vaultMint;
        });
    }
    createATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(this.tokenMint.address, owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(this.vaultState.lpMint, owner, this.connection);
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                userToken,
                userLpToken,
            };
        });
    }
    createAffiliateATAPreInstructions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('Affiliate ID or program not found');
            const partner = this.affiliateId;
            const partnerToken = (0, utils_1.getAssociatedTokenAccount)(this.tokenMint.address, partner);
            const [partnerAddress, _nonce] = web3_js_1.PublicKey.findProgramAddressSync([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const [userAddress, _nonceUser] = web3_js_1.PublicKey.findProgramAddressSync([partnerAddress.toBuffer(), owner.toBuffer()], this.affiliateProgram.programId);
            let preInstructions = [];
            const [userToken, createUserTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(this.tokenMint.address, owner, this.connection);
            const [userLpToken, createUserLpTokenIx] = yield (0, utils_1.getOrCreateATAInstruction)(this.vaultState.lpMint, userAddress, this.connection, {
                payer: owner,
            });
            if (createUserTokenIx) {
                preInstructions.push(createUserTokenIx);
            }
            if (createUserLpTokenIx) {
                preInstructions.push(createUserLpTokenIx);
            }
            return {
                preInstructions,
                partner,
                partnerAddress,
                userAddress,
                userToken,
                userLpToken,
            };
        });
    }
    deposit(owner, baseTokenAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            // Refresh vault state
            yield this.refreshVaultState();
            let preInstructions = [];
            let partnerAddress;
            let userAddress;
            let userToken;
            let userLpToken;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress: partnerAddressATA, userAddress: userAddressATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
                partnerAddress = partnerAddressATA;
                userAddress = userAddressATA;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            // If it's SOL vault, wrap desired amount of SOL
            if (this.tokenMint.address.equals(spl_token_1.NATIVE_MINT)) {
                preInstructions = preInstructions.concat((0, utils_1.wrapSOLInstruction)(owner, userToken, baseTokenAmount));
            }
            let depositTx;
            if (partnerAddress && userAddress && this.affiliateId && this.affiliateProgram) {
                const userPda = yield this.connection.getParsedAccountInfo(userAddress);
                if (!userPda || !((_a = userPda.value) === null || _a === void 0 ? void 0 : _a.data)) {
                    // Init first time user
                    preInstructions.push(yield this.affiliateProgram.methods
                        .initUser()
                        .accounts({
                        user: userAddress,
                        partner: partnerAddress,
                        owner,
                        systemProgram: web3_js_1.SystemProgram.programId,
                        rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                    })
                        .instruction());
                }
                depositTx = yield this.affiliateProgram.methods
                    .deposit(new anchor_1.BN(baseTokenAmount.toString()), new anchor_1.BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    partner: partnerAddress,
                    user: userAddress,
                    vaultProgram: this.program.programId,
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    vaultLpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    owner,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            else {
                depositTx = yield this.program.methods
                    .deposit(new anchor_1.BN(baseTokenAmount.toString()), new anchor_1.BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    lpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    user: owner,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .transaction();
            }
            return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(depositTx);
        });
    }
    getStrategiesState() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.program.account.strategy.fetchMultiple(this.vaultState.strategies.filter((address) => address.toString() !== constants_1.VAULT_STRATEGY_ADDRESS))).filter(Boolean);
        });
    }
    getStrategyWithHighestLiquidity(strategy) {
        return __awaiter(this, void 0, void 0, function* () {
            // Reserved for testing
            if (strategy) {
                const strategyState = (yield this.program.account.strategy.fetchNullable(strategy));
                return { publicKey: strategy, strategyState };
            }
            const vaultStrategiesStatePromise = this.vaultState.strategies
                .filter((address) => address.toString() !== constants_1.VAULT_STRATEGY_ADDRESS)
                .map((strat) => __awaiter(this, void 0, void 0, function* () {
                const strategyState = (yield this.program.account.strategy.fetch(strat));
                return { publicKey: strat, strategyState };
            }));
            const vaultStrategiesState = yield Promise.allSettled(vaultStrategiesStatePromise);
            const settledVaultStrategiesState = vaultStrategiesState
                .map((item) => (item.status === 'fulfilled' ? item.value : undefined))
                .filter(Boolean);
            const highestLiquidity = settledVaultStrategiesState.sort((a, b) => b.strategyState.currentLiquidity.sub(a.strategyState.currentLiquidity).toNumber())[0];
            return highestLiquidity;
        });
    }
    withdraw(owner, baseTokenAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            // Refresh vault state
            yield this.refreshVaultState();
            const lpSupply = yield this.getVaultSupply();
            let preInstructions = [];
            let userToken;
            let userLpToken;
            let withdrawOpt;
            // Withdraw with Affiliate
            if (this.affiliateId && this.affiliateProgram) {
                const { preInstructions: preInstructionsATA, partnerAddress, userAddress, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createAffiliateATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
                withdrawOpt =
                    this.affiliateId && this.affiliateProgram
                        ? {
                            affiliate: {
                                affiliateId: this.affiliateId,
                                affiliateProgram: this.affiliateProgram,
                                partner: partnerAddress,
                                user: userAddress,
                            },
                        }
                        : undefined;
            }
            else {
                // Without affiliate
                const { preInstructions: preInstructionsATA, userToken: userTokenATA, userLpToken: userLpTokenATA, } = yield this.createATAPreInstructions(owner);
                preInstructions = preInstructionsATA;
                userToken = userTokenATA;
                userLpToken = userLpTokenATA;
            }
            const unlockedAmount = yield this.getWithdrawableAmount();
            const amountToWithdraw = baseTokenAmount.mul(unlockedAmount).div(lpSupply);
            const vaultLiquidity = new anchor_1.BN((yield getVaultLiquidity(this.connection, this.tokenVaultPda)) || 0);
            if (amountToWithdraw.lt(vaultLiquidity) // If withdraw amount lesser than vault reserve
            ) {
                return this.withdrawFromVaultReserve(owner, baseTokenAmount, userToken, userLpToken, preInstructions, withdrawOpt);
            }
            // Get strategy with highest liquidity
            // opt.strategy reserved for testing
            const selectedStrategy = yield this.getStrategyWithHighestLiquidity();
            const currentLiquidity = new anchor_1.BN(selectedStrategy.strategyState.currentLiquidity);
            const availableAmount = currentLiquidity.add(vaultLiquidity);
            if (amountToWithdraw.gt(availableAmount)) {
                throw new Error('Selected strategy does not have enough liquidity.');
            }
            const strategyHandler = new vault_1.default();
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenMint.address.equals(spl_token_1.NATIVE_MINT)) {
                const closeWrappedSOLIx = yield (0, utils_1.unwrapSOLInstruction)(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            const withdrawFromStrategyTx = yield strategyHandler.withdraw(owner, this.program, {
                pubkey: selectedStrategy.publicKey,
                state: selectedStrategy.strategyState,
            }, this.vaultPda, this.tokenVaultPda, this.vaultState, userToken, userLpToken, baseTokenAmount, preInstructions, postInstruction, withdrawOpt);
            const tx = new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawFromStrategyTx);
            return tx;
        });
    }
    // Reserved code to withdraw from Vault Reserves directly.
    // The only situation this piece of code will be required, is when a single Vault have no other strategy, and only have its own reserve.
    withdrawFromVaultReserve(owner, baseTokenAmount, userToken, userLpToken, preInstructions, withdrawOpt) {
        return __awaiter(this, void 0, void 0, function* () {
            // Unwrap SOL
            const postInstruction = [];
            if (this.tokenMint.address.equals(spl_token_1.NATIVE_MINT)) {
                const closeWrappedSOLIx = yield (0, utils_1.unwrapSOLInstruction)(owner);
                if (closeWrappedSOLIx) {
                    postInstruction.push(closeWrappedSOLIx);
                }
            }
            let withdrawTx;
            if (withdrawOpt === null || withdrawOpt === void 0 ? void 0 : withdrawOpt.affiliate) {
                withdrawTx = yield withdrawOpt.affiliate.affiliateProgram.methods
                    .withdraw(baseTokenAmount, new anchor_1.BN(0))
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    vaultLpMint: this.vaultState.lpMint,
                    partner: withdrawOpt.affiliate.partner,
                    owner,
                    userToken,
                    vaultProgram: this.program.programId,
                    userLp: userLpToken,
                    user: withdrawOpt.affiliate.user,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .postInstructions(postInstruction)
                    .transaction();
            }
            else {
                withdrawTx = yield this.program.methods
                    .withdraw(baseTokenAmount, new anchor_1.BN(0)) // Vault does not have slippage, second parameter is ignored.
                    .accounts({
                    vault: this.vaultPda,
                    tokenVault: this.tokenVaultPda,
                    lpMint: this.vaultState.lpMint,
                    userToken,
                    userLp: userLpToken,
                    user: owner,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                })
                    .preInstructions(preInstructions)
                    .postInstructions(postInstruction)
                    .transaction();
            }
            return new web3_js_1.Transaction(Object.assign({ feePayer: owner }, (yield this.connection.getLatestBlockhash()))).add(withdrawTx);
        });
    }
    getAffiliateInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.affiliateId || !this.affiliateProgram)
                throw new Error('No affiliateId or affiliate program found');
            const partner = this.affiliateId;
            const partnerToken = (0, utils_1.getAssociatedTokenAccount)(this.tokenMint.address, partner);
            const [partnerAddress, _nonce] = web3_js_1.PublicKey.findProgramAddressSync([this.vaultPda.toBuffer(), partnerToken.toBuffer()], this.affiliateProgram.programId);
            const partnerDetails = (yield this.affiliateProgram.account.partner.fetchNullable(partnerAddress));
            return partnerDetails;
        });
    }
}
exports.default = VaultImpl;
//# sourceMappingURL=index.js.map