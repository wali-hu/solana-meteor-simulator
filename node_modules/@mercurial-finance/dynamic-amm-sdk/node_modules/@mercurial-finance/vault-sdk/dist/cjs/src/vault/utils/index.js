"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLpSupply = exports.getOnchainTime = exports.unwrapSOLInstruction = exports.wrapSOLInstruction = exports.getVaultPdas = exports.getOrCreateATAInstruction = exports.deserializeAccount = exports.getAssociatedTokenAccount = void 0;
exports.chunks = chunks;
exports.chunkedFetchMultipleVaultAccount = chunkedFetchMultipleVaultAccount;
exports.chunkedGetMultipleAccountInfos = chunkedGetMultipleAccountInfos;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@coral-xyz/anchor");
const constants_1 = require("../constants");
const getAssociatedTokenAccount = (tokenMint, owner) => {
    return (0, spl_token_1.getAssociatedTokenAddressSync)(tokenMint, owner, true, spl_token_1.TOKEN_PROGRAM_ID, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
};
exports.getAssociatedTokenAccount = getAssociatedTokenAccount;
const deserializeAccount = (data) => {
    if (data == undefined || data.length == 0) {
        return undefined;
    }
    const accountInfo = spl_token_1.AccountLayout.decode(data);
    return accountInfo;
};
exports.deserializeAccount = deserializeAccount;
const getOrCreateATAInstruction = (tokenAddress, owner, connection, opt) => __awaiter(void 0, void 0, void 0, function* () {
    let toAccount;
    try {
        toAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(tokenAddress, owner, true, spl_token_1.TOKEN_PROGRAM_ID, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
        const account = yield connection.getAccountInfo(toAccount);
        if (!account) {
            const ix = (0, spl_token_1.createAssociatedTokenAccountInstruction)((opt === null || opt === void 0 ? void 0 : opt.payer) || owner, toAccount, owner, tokenAddress, spl_token_1.TOKEN_PROGRAM_ID, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
            return [toAccount, ix];
        }
        return [toAccount, undefined];
    }
    catch (e) {
        /* handle error */
        console.error('Error::getOrCreateATAInstruction', e);
        throw e;
    }
});
exports.getOrCreateATAInstruction = getOrCreateATAInstruction;
const getVaultPdas = (tokenMint, programId, seedBaseKey) => {
    const [vault, _vaultBump] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from(constants_1.SEEDS.VAULT_PREFIX), tokenMint.toBuffer(), (seedBaseKey !== null && seedBaseKey !== void 0 ? seedBaseKey : constants_1.VAULT_BASE_KEY).toBuffer()], programId);
    const [tokenVault] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from(constants_1.SEEDS.TOKEN_VAULT_PREFIX), vault.toBuffer()], programId);
    const [lpMint] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from(constants_1.SEEDS.LP_MINT_PREFIX), vault.toBuffer()], programId);
    return {
        vaultPda: vault,
        tokenVaultPda: tokenVault,
        lpMintPda: lpMint,
    };
};
exports.getVaultPdas = getVaultPdas;
const wrapSOLInstruction = (from, to, amount) => {
    return [
        web3_js_1.SystemProgram.transfer({
            fromPubkey: from,
            toPubkey: to,
            lamports: amount.toNumber(),
        }),
        new web3_js_1.TransactionInstruction({
            keys: [
                {
                    pubkey: to,
                    isSigner: false,
                    isWritable: true,
                },
            ],
            data: Buffer.from(new Uint8Array([17])),
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }),
    ];
};
exports.wrapSOLInstruction = wrapSOLInstruction;
const unwrapSOLInstruction = (walletPublicKey) => __awaiter(void 0, void 0, void 0, function* () {
    const wSolATAAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(spl_token_1.NATIVE_MINT, walletPublicKey, true, spl_token_1.TOKEN_PROGRAM_ID, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
    if (wSolATAAccount) {
        const closedWrappedSolInstruction = (0, spl_token_1.createCloseAccountInstruction)(wSolATAAccount, walletPublicKey, walletPublicKey, []);
        return closedWrappedSolInstruction;
    }
    return null;
});
exports.unwrapSOLInstruction = unwrapSOLInstruction;
const getOnchainTime = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const parsedClock = yield connection.getParsedAccountInfo(web3_js_1.SYSVAR_CLOCK_PUBKEY);
    const parsedClockAccount = parsedClock.value.data.parsed;
    const currentTime = parsedClockAccount.info.unixTimestamp;
    return currentTime;
});
exports.getOnchainTime = getOnchainTime;
const getLpSupply = (connection, tokenMint) => __awaiter(void 0, void 0, void 0, function* () {
    const context = yield connection.getTokenSupply(tokenMint);
    return new anchor_1.BN(context.value.amount);
});
exports.getLpSupply = getLpSupply;
function chunks(array, size) {
    return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index) => array.slice(index * size, (index + 1) * size));
}
function chunkedFetchMultipleVaultAccount(program_1, pks_1) {
    return __awaiter(this, arguments, void 0, function* (program, pks, chunkSize = 100) {
        const accounts = (yield Promise.all(chunks(pks, chunkSize).map((chunk) => program.account.vault.fetchMultiple(chunk)))).flat();
        return accounts.filter(Boolean);
    });
}
function chunkedGetMultipleAccountInfos(connection_1, pks_1) {
    return __awaiter(this, arguments, void 0, function* (connection, pks, chunkSize = 100) {
        const accountInfos = (yield Promise.all(chunks(pks, chunkSize).map((chunk) => connection.getMultipleAccountsInfo(chunk)))).flat();
        return accountInfos;
    });
}
//# sourceMappingURL=index.js.map