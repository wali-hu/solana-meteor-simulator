var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, NATIVE_MINT, getAssociatedTokenAddressSync, createAssociatedTokenAccountInstruction, createCloseAccountInstruction, AccountLayout, } from '@solana/spl-token';
import { PublicKey, SystemProgram, SYSVAR_CLOCK_PUBKEY, TransactionInstruction, } from '@solana/web3.js';
import { BN } from '@coral-xyz/anchor';
import { SEEDS, VAULT_BASE_KEY } from '../constants';
export const getAssociatedTokenAccount = (tokenMint, owner) => {
    return getAssociatedTokenAddressSync(tokenMint, owner, true, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID);
};
export const deserializeAccount = (data) => {
    if (data == undefined || data.length == 0) {
        return undefined;
    }
    const accountInfo = AccountLayout.decode(data);
    return accountInfo;
};
export const getOrCreateATAInstruction = (tokenAddress, owner, connection, opt) => __awaiter(void 0, void 0, void 0, function* () {
    let toAccount;
    try {
        toAccount = getAssociatedTokenAddressSync(tokenAddress, owner, true, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID);
        const account = yield connection.getAccountInfo(toAccount);
        if (!account) {
            const ix = createAssociatedTokenAccountInstruction((opt === null || opt === void 0 ? void 0 : opt.payer) || owner, toAccount, owner, tokenAddress, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID);
            return [toAccount, ix];
        }
        return [toAccount, undefined];
    }
    catch (e) {
        /* handle error */
        console.error('Error::getOrCreateATAInstruction', e);
        throw e;
    }
});
export const getVaultPdas = (tokenMint, programId, seedBaseKey) => {
    const [vault, _vaultBump] = PublicKey.findProgramAddressSync([Buffer.from(SEEDS.VAULT_PREFIX), tokenMint.toBuffer(), (seedBaseKey !== null && seedBaseKey !== void 0 ? seedBaseKey : VAULT_BASE_KEY).toBuffer()], programId);
    const [tokenVault] = PublicKey.findProgramAddressSync([Buffer.from(SEEDS.TOKEN_VAULT_PREFIX), vault.toBuffer()], programId);
    const [lpMint] = PublicKey.findProgramAddressSync([Buffer.from(SEEDS.LP_MINT_PREFIX), vault.toBuffer()], programId);
    return {
        vaultPda: vault,
        tokenVaultPda: tokenVault,
        lpMintPda: lpMint,
    };
};
export const wrapSOLInstruction = (from, to, amount) => {
    return [
        SystemProgram.transfer({
            fromPubkey: from,
            toPubkey: to,
            lamports: amount.toNumber(),
        }),
        new TransactionInstruction({
            keys: [
                {
                    pubkey: to,
                    isSigner: false,
                    isWritable: true,
                },
            ],
            data: Buffer.from(new Uint8Array([17])),
            programId: TOKEN_PROGRAM_ID,
        }),
    ];
};
export const unwrapSOLInstruction = (walletPublicKey) => __awaiter(void 0, void 0, void 0, function* () {
    const wSolATAAccount = getAssociatedTokenAddressSync(NATIVE_MINT, walletPublicKey, true, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID);
    if (wSolATAAccount) {
        const closedWrappedSolInstruction = createCloseAccountInstruction(wSolATAAccount, walletPublicKey, walletPublicKey, []);
        return closedWrappedSolInstruction;
    }
    return null;
});
export const getOnchainTime = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const parsedClock = yield connection.getParsedAccountInfo(SYSVAR_CLOCK_PUBKEY);
    const parsedClockAccount = parsedClock.value.data.parsed;
    const currentTime = parsedClockAccount.info.unixTimestamp;
    return currentTime;
});
export const getLpSupply = (connection, tokenMint) => __awaiter(void 0, void 0, void 0, function* () {
    const context = yield connection.getTokenSupply(tokenMint);
    return new BN(context.value.amount);
});
export function chunks(array, size) {
    return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index) => array.slice(index * size, (index + 1) * size));
}
export function chunkedFetchMultipleVaultAccount(program_1, pks_1) {
    return __awaiter(this, arguments, void 0, function* (program, pks, chunkSize = 100) {
        const accounts = (yield Promise.all(chunks(pks, chunkSize).map((chunk) => program.account.vault.fetchMultiple(chunk)))).flat();
        return accounts.filter(Boolean);
    });
}
export function chunkedGetMultipleAccountInfos(connection_1, pks_1) {
    return __awaiter(this, arguments, void 0, function* (connection, pks, chunkSize = 100) {
        const accountInfos = (yield Promise.all(chunks(pks, chunkSize).map((chunk) => connection.getMultipleAccountsInfo(chunk)))).flat();
        return accountInfos;
    });
}
//# sourceMappingURL=index.js.map