"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/stake-for-fee/index.ts
var _anchor = require('@coral-xyz/anchor');






var _spltoken = require('@solana/spl-token');




var _web3js = require('@solana/web3.js');

// src/stake-for-fee/constants/index.ts

var _bnjs = require('bn.js'); var _bnjs2 = _interopRequireDefault(_bnjs);
var STAKE_FOR_FEE_PROGRAM_ID = new (0, _web3js.PublicKey)(
  "FEESngU3neckdwib9X3KWqdL7Mjmqk9XNp3uh5JbP4KP"
);
var DYNAMIC_AMM_PROGRAM_ID = new (0, _web3js.PublicKey)(
  "Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"
);
var DYNAMIC_VAULT_PROGRAM_ID = new (0, _web3js.PublicKey)(
  "24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi"
);
var FULL_BALANCE_LIST_HARD_LIMIT = new (0, _bnjs.BN)(1e4);
var U64_MAX = new (0, _bnjs.BN)("18446744073709551615");

// src/stake-for-fee/helpers/decoder.ts
function decodeFullBalanceState(stakeForFeeProgram, account) {
  const metadata = stakeForFeeProgram.coder.accounts.decode(
    "fullBalanceListMetadata",
    account.data
  );
  const stakerBalances = [];
  const stakerBalanceSize = 48;
  const fullBalanceListSlice = account.data.slice(8 + 40);
  for (let i = 0; i < metadata.length.toNumber(); i++) {
    const offset = i * stakerBalanceSize;
    const slice = fullBalanceListSlice.slice(
      offset,
      offset + stakerBalanceSize
    );
    const stakerBalance = stakeForFeeProgram.coder.types.decode(
      "StakerBalance",
      Buffer.from(slice)
    );
    stakerBalances.push(stakerBalance);
  }
  return {
    metadata,
    stakers: stakerBalances
  };
}
function decodeTopStakerListState(stakeForFeeProgram, feeVault, account) {
  const topStakerMetadataState = stakeForFeeProgram.coder.accounts.decode("topListMetadata", account.data);
  const topStakerListSlice = account.data.slice(8 + 32);
  const stakerMetadataSize = 48;
  const topStakerList = {
    metadata: topStakerMetadataState,
    stakers: []
  };
  for (let i = 0; i < feeVault.topStakerInfo.currentLength.toNumber(); i++) {
    const offset = i * stakerMetadataSize;
    const slice = topStakerListSlice.slice(offset, offset + stakerMetadataSize);
    const stakerMetadata = stakeForFeeProgram.coder.types.decode(
      "StakerMetadata",
      Buffer.from(slice)
    );
    topStakerList.stakers.push(stakerMetadata);
  }
  return topStakerList;
}

// src/stake-for-fee/helpers/dynamic_amm.ts


// src/stake-for-fee/types/index.ts

var _borsh = require('@coral-xyz/borsh');
var MIN_LOCK_ESCROW_CLAIM_FEE_DURATION = new (0, _anchor.BN)(300);
var ClockLayout = _borsh.struct.call(void 0, [
  _borsh.u64.call(void 0, "slot"),
  _borsh.i64.call(void 0, "epochStartTimestamp"),
  _borsh.u64.call(void 0, "epoch"),
  _borsh.u64.call(void 0, "leaderScheduleEpoch"),
  _borsh.i64.call(void 0, "unixTimestamp")
]);

// src/stake-for-fee/helpers/dynamic_vault.ts

var LOCKED_PROFIT_DEGRADATION_DENOMINATOR = new (0, _bnjs2.default)(1e12);
function calculateLockedProfit(currentTime, dynamicVault) {
  const duration = currentTime.sub(dynamicVault.lockedProfitTracker.lastReport);
  const lockedFundRatio = duration.mul(
    dynamicVault.lockedProfitTracker.lockedProfitDegradation
  );
  if (lockedFundRatio.gt(LOCKED_PROFIT_DEGRADATION_DENOMINATOR)) {
    return new (0, _bnjs2.default)(0);
  }
  const lockedProfit = dynamicVault.lockedProfitTracker.lastUpdatedLockedProfit.mul(LOCKED_PROFIT_DEGRADATION_DENOMINATOR.sub(lockedFundRatio)).div(LOCKED_PROFIT_DEGRADATION_DENOMINATOR);
  return lockedProfit;
}
function getUnlockedAmount(currentTime, dynamicVault) {
  return dynamicVault.totalAmount.sub(
    calculateLockedProfit(currentTime, dynamicVault)
  );
}
function getAmountByShare(currentTime, dynamicVault, share, totalSupply) {
  const totalAmount = getUnlockedAmount(currentTime, dynamicVault);
  return totalAmount.mul(share).div(totalSupply);
}

// src/stake-for-fee/helpers/dynamic_amm.ts
var _decimaljs = require('decimal.js'); var _decimaljs2 = _interopRequireDefault(_decimaljs);
function getTokenBalances(currentTime, aVault, bVault, aVaultLp, bVaultLp, aVaultLpMint, bVaultLpMint) {
  const tokenAAmount = getAmountByShare(
    currentTime,
    aVault,
    new (0, _bnjs2.default)(aVaultLp.amount.toString()),
    new (0, _bnjs2.default)(aVaultLpMint.supply.toString())
  );
  const tokenBAmount = getAmountByShare(
    currentTime,
    bVault,
    new (0, _bnjs2.default)(bVaultLp.amount.toString()),
    new (0, _bnjs2.default)(bVaultLpMint.supply.toString())
  );
  return [tokenAAmount, tokenBAmount];
}
function getVirtualPrice(tokenAAmount, tokenBAmount, lpSupply) {
  if (lpSupply.isZero()) {
    return new (0, _bnjs2.default)(0);
  }
  const k = tokenAAmount.mul(tokenBAmount);
  const d = new (0, _bnjs2.default)(new (0, _decimaljs2.default)(k.toString()).sqrt().floor().toString());
  return d.shln(64).div(lpSupply);
}
function getLockedEscrowPendingFee(currentTime, feeVault, lockEscrow, aVault, bVault, aVaultLp, bVaultLp, aVaultLpMint, bVaultLpMint, poolLpMint) {
  if (currentTime.lte(feeVault.topStakerInfo.lastClaimFeeAt)) {
    return [new (0, _bnjs2.default)(0), new (0, _bnjs2.default)(0)];
  }
  const secondsElapsedSinceLastClaim = currentTime.sub(
    feeVault.topStakerInfo.lastClaimFeeAt
  );
  if (secondsElapsedSinceLastClaim.lt(MIN_LOCK_ESCROW_CLAIM_FEE_DURATION)) {
    return [new (0, _bnjs2.default)(0), new (0, _bnjs2.default)(0)];
  }
  const [tokenAAmount, tokenBAmount] = getTokenBalances(
    currentTime,
    aVault,
    bVault,
    aVaultLp,
    bVaultLp,
    aVaultLpMint,
    bVaultLpMint
  );
  const currentLpPerToken = getVirtualPrice(
    tokenAAmount,
    tokenBAmount,
    new (0, _bnjs2.default)(poolLpMint.supply.toString())
  );
  const newFee = currentLpPerToken.gt(lockEscrow.lpPerToken) ? lockEscrow.totalLockedAmount.mul(currentLpPerToken.sub(lockEscrow.lpPerToken)).div(currentLpPerToken) : new (0, _bnjs2.default)(0);
  if (newFee.isZero()) {
    return [new (0, _bnjs2.default)(0), new (0, _bnjs2.default)(0)];
  }
  const aVaultLpToBurn = newFee.mul(new (0, _bnjs2.default)(aVaultLp.amount.toString())).div(new (0, _bnjs2.default)(poolLpMint.supply.toString()));
  const bVaultLpToBurn = newFee.mul(new (0, _bnjs2.default)(bVaultLp.amount.toString())).div(new (0, _bnjs2.default)(poolLpMint.supply.toString()));
  const feeA = getAmountByShare(
    currentTime,
    aVault,
    aVaultLpToBurn,
    new (0, _bnjs2.default)(aVaultLpMint.supply.toString())
  );
  const feeB = getAmountByShare(
    currentTime,
    bVault,
    bVaultLpToBurn,
    new (0, _bnjs2.default)(bVaultLpMint.supply.toString())
  );
  return [feeA, feeB];
}

// src/stake-for-fee/helpers/pda.ts

var deriveLockEscrowPda = (pool, owner, ammProgram) => {
  return _web3js.PublicKey.findProgramAddressSync(
    [Buffer.from("lock_escrow"), pool.toBuffer(), owner.toBuffer()],
    ammProgram
  );
};
var deriveFeeVault = (pool, programId) => {
  return _web3js.PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), pool.toBytes()],
    programId
  )[0];
};
var deriveTopStakerList = (vault, programId) => {
  return _web3js.PublicKey.findProgramAddressSync(
    [Buffer.from("list"), vault.toBytes()],
    programId
  )[0];
};
var deriveFullBalanceList = (vault, programId) => {
  return _web3js.PublicKey.findProgramAddressSync(
    [Buffer.from("balance"), vault.toBytes()],
    programId
  )[0];
};
var deriveStakeEscrow = (vault, owner, programId) => {
  return _web3js.PublicKey.findProgramAddressSync(
    [Buffer.from("escrow"), vault.toBytes(), owner.toBytes()],
    programId
  )[0];
};
var deriveLpMint = (poolAddress, programId) => {
  return _web3js.PublicKey.findProgramAddressSync(
    [Buffer.from("lp_mint"), poolAddress.toBuffer()],
    new (0, _web3js.PublicKey)(programId || DYNAMIC_AMM_PROGRAM_ID)
  )[0];
};

// src/stake-for-fee/helpers/program.ts





// src/stake-for-fee/idls/stake_for_fee.ts
var IDL = {
  "version": "0.1.1",
  "name": "stake_for_fee",
  "instructions": [
    {
      "name": "initializeVault",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "stakeTokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Token a vault"
          ]
        },
        {
          "name": "quoteTokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Token b vault"
          ]
        },
        {
          "name": "topStakerList",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Top staker list account"
          ]
        },
        {
          "name": "fullBalanceList",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Full balance list account"
          ]
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Pool account"
          ]
        },
        {
          "name": "stakeMint",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Stake mint"
          ]
        },
        {
          "name": "quoteMint",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Quote mint"
          ]
        },
        {
          "name": "lockEscrow",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Escrow account"
          ]
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "associatedTokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "params",
          "type": {
            "defined": "InitializeVaultParams"
          }
        }
      ]
    },
    {
      "name": "initializeStakeEscrow",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "escrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "fullBalanceList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "topStakerList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "stake",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "quoteTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "topStakerList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "fullBalanceList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "smallestStakeEscrow",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userStakeToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lockEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "escrowVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "ammProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "vaultProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "claimFee",
      "docs": [
        "The endpoint will only claim the quote token (SOL or USDC). The meme token will be automatically restaked."
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "topStakerList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "fullBalanceList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "smallestStakeEscrow",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userQuoteToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "quoteTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lockEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "escrowVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "ammProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "vaultProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "maxFee",
          "type": "u64"
        }
      ]
    },
    {
      "name": "requestUnstake",
      "accounts": [
        {
          "name": "unstake",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "topStakerList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "fullBalanceList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "quoteTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lockEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "escrowVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "ammProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "vaultProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "unstakeAmount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "cancelUnstake",
      "accounts": [
        {
          "name": "unstake",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "smallestStakeEscrow",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "topStakerList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "fullBalanceList",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "quoteTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lockEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "escrowVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "ammProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "vaultProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "withdraw",
      "accounts": [
        {
          "name": "unstake",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userStakeToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "claimFeeCrank",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "stakeTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "quoteTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lockEscrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "escrowVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "ammProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "vaultProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "updateUnstakeLockDuration",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "unstakeLockDuration",
          "type": "u64"
        }
      ]
    },
    {
      "name": "updateSecondsToFullUnlock",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "instructionsSysvar",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "secondsToFullUnlock",
          "type": "u64"
        }
      ]
    },
    {
      "name": "dummy",
      "docs": [
        "To force IDL generation for some struct for easier TS decoding later"
      ],
      "accounts": [
        {
          "name": "stakerMetadata",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "stakerBalance",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "stakerMetadataDummyAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "stakerMetadata",
            "type": {
              "defined": "StakerMetadata"
            }
          }
        ]
      }
    },
    {
      "name": "stakerBalanceDummyAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "stakerBalance",
            "type": {
              "defined": "StakerBalance"
            }
          }
        ]
      }
    },
    {
      "name": "fullBalanceListMetadata",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "vault",
            "type": "publicKey"
          },
          {
            "name": "length",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "stakeEscrow",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "owner",
            "type": "publicKey"
          },
          {
            "name": "vault",
            "type": "publicKey"
          },
          {
            "name": "fullBalanceIndex",
            "type": "u64"
          },
          {
            "name": "stakeAmount",
            "type": "u64"
          },
          {
            "name": "inTopList",
            "type": "u8"
          },
          {
            "name": "padding0",
            "type": {
              "array": [
                "u8",
                15
              ]
            }
          },
          {
            "name": "ongoingTotalPartialUnstakeAmount",
            "type": "u64"
          },
          {
            "name": "createdAt",
            "type": "i64"
          },
          {
            "name": "feeAClaimedAmount",
            "type": "u128"
          },
          {
            "name": "feeBClaimedAmount",
            "type": "u128"
          },
          {
            "name": "feeAPerLiquidityCheckpoint",
            "type": "u128"
          },
          {
            "name": "feeBPerLiquidityCheckpoint",
            "type": "u128"
          },
          {
            "name": "feeAPending",
            "type": "u64"
          },
          {
            "name": "feeBPending",
            "type": "u64"
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u128",
                20
              ]
            }
          }
        ]
      }
    },
    {
      "name": "topListMetadata",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "vault",
            "docs": [
              "Vault"
            ],
            "type": "publicKey"
          }
        ]
      }
    },
    {
      "name": "unstake",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "stakeEscrow",
            "type": "publicKey"
          },
          {
            "name": "unstakeAmount",
            "type": "u64"
          },
          {
            "name": "createdAt",
            "type": "i64"
          },
          {
            "name": "releaseAt",
            "type": "i64"
          },
          {
            "name": "owner",
            "docs": [
              "owner field, only be used for indexing"
            ],
            "type": "publicKey"
          },
          {
            "name": "vault",
            "docs": [
              "vault field, only be used for indexing"
            ],
            "type": "publicKey"
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u64",
                22
              ]
            }
          }
        ]
      }
    },
    {
      "name": "feeVault",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "lockEscrow",
            "docs": [
              "Lock escrow account"
            ],
            "type": "publicKey"
          },
          {
            "name": "stakeMint",
            "docs": [
              "Stake mint"
            ],
            "type": "publicKey"
          },
          {
            "name": "quoteMint",
            "docs": [
              "Quote mint"
            ],
            "type": "publicKey"
          },
          {
            "name": "pool",
            "docs": [
              "Pool"
            ],
            "type": "publicKey"
          },
          {
            "name": "stakeTokenVault",
            "docs": [
              "Stake token vault"
            ],
            "type": "publicKey"
          },
          {
            "name": "quoteTokenVault",
            "docs": [
              "Quote token vault"
            ],
            "type": "publicKey"
          },
          {
            "name": "topStakerList",
            "docs": [
              "Top staker list"
            ],
            "type": "publicKey"
          },
          {
            "name": "fullBalanceList",
            "docs": [
              "Full balance list"
            ],
            "type": "publicKey"
          },
          {
            "name": "metrics",
            "docs": [
              "Metrics"
            ],
            "type": {
              "defined": "Metrics"
            }
          },
          {
            "name": "configuration",
            "docs": [
              "Configuration parameters"
            ],
            "type": {
              "defined": "Configuration"
            }
          },
          {
            "name": "topStakerInfo",
            "docs": [
              "Top staker info"
            ],
            "type": {
              "defined": "TopStakerInfo"
            }
          },
          {
            "name": "creator",
            "docs": [
              "Creator"
            ],
            "type": "publicKey"
          },
          {
            "name": "createdAt",
            "docs": [
              "Created at"
            ],
            "type": "i64"
          },
          {
            "name": "bump",
            "docs": [
              "Bump"
            ],
            "type": "u8"
          },
          {
            "name": "padding0",
            "docs": [
              "Padding"
            ],
            "type": {
              "array": [
                "u8",
                7
              ]
            }
          },
          {
            "name": "padding",
            "docs": [
              "Padding"
            ],
            "type": {
              "array": [
                "u128",
                20
              ]
            }
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "InitializeVaultParams",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "topListLength",
            "type": "u16"
          },
          {
            "name": "secondsToFullUnlock",
            "type": "u64"
          },
          {
            "name": "unstakeLockDuration",
            "type": "u64"
          },
          {
            "name": "startFeeDistributeTimestamp",
            "type": {
              "option": "u64"
            }
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u8",
                64
              ]
            }
          }
        ]
      }
    },
    {
      "name": "StakerBalance",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "balance",
            "docs": [
              "Balance"
            ],
            "type": "u64"
          },
          {
            "name": "owner",
            "docs": [
              "Owner pubkey, we don't need this for logic, but it is useful for indexing"
            ],
            "type": "publicKey"
          },
          {
            "name": "isInTopList",
            "docs": [
              "In top list"
            ],
            "type": "u8"
          },
          {
            "name": "padding",
            "docs": [
              "Padding"
            ],
            "type": {
              "array": [
                "u8",
                7
              ]
            }
          }
        ]
      }
    },
    {
      "name": "StakerMetadata",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "stakeAmount",
            "docs": [
              "Staked amount"
            ],
            "type": "u64"
          },
          {
            "name": "fullBalanceIndex",
            "docs": [
              "Full balance list index. When it's negative, the slot is empty"
            ],
            "type": "i64"
          },
          {
            "name": "owner",
            "docs": [
              "Owner pubkey, we dont need this for logic, but it is useful for indexing"
            ],
            "type": "publicKey"
          }
        ]
      }
    },
    {
      "name": "Configuration",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "secondsToFullUnlock",
            "docs": [
              "Time required for locked claim fee to be fully dripped"
            ],
            "type": "u64"
          },
          {
            "name": "unstakeLockDuration",
            "docs": [
              "Unstake lock duration"
            ],
            "type": "u64"
          },
          {
            "name": "startFeeDistributeTimestamp",
            "docs": [
              "When the fee start distributes"
            ],
            "type": "i64"
          },
          {
            "name": "padding0",
            "docs": [
              "padding 0"
            ],
            "type": "u64"
          },
          {
            "name": "padding",
            "docs": [
              "padding"
            ],
            "type": {
              "array": [
                "u128",
                4
              ]
            }
          }
        ]
      }
    },
    {
      "name": "Metrics",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "totalStakedAmount",
            "docs": [
              "Total staked amount"
            ],
            "type": "u64"
          },
          {
            "name": "totalStakeEscrowCount",
            "docs": [
              "Total stake escrow count"
            ],
            "type": "u64"
          },
          {
            "name": "ongoingTotalPartialUnstakeAmount",
            "docs": [
              "Ongoing total partial unstake amount"
            ],
            "type": "u64"
          },
          {
            "name": "padding0",
            "docs": [
              "padding 0"
            ],
            "type": "u64"
          },
          {
            "name": "totalFeeAAmount",
            "docs": [
              "Total claimed fee a amount"
            ],
            "type": "u128"
          },
          {
            "name": "totalFeeBAmount",
            "docs": [
              "Total claimed fee b amount"
            ],
            "type": "u128"
          },
          {
            "name": "userTotalClaimedFeeA",
            "docs": [
              "User total claimed fee a"
            ],
            "type": "u128"
          },
          {
            "name": "userTotalClaimedFeeB",
            "docs": [
              "User total claimed fee b"
            ],
            "type": "u128"
          },
          {
            "name": "padding",
            "docs": [
              "padding"
            ],
            "type": {
              "array": [
                "u128",
                4
              ]
            }
          }
        ]
      }
    },
    {
      "name": "TopStakerInfo",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "topListLength",
            "docs": [
              "Number of holder in the top list"
            ],
            "type": "u64"
          },
          {
            "name": "currentLength",
            "docs": [
              "Current length, used for resize"
            ],
            "type": "u64"
          },
          {
            "name": "effectiveStakeAmount",
            "docs": [
              "Effective stake amount. Total stake amount in the top list."
            ],
            "type": "u64"
          },
          {
            "name": "lastClaimFeeAt",
            "docs": [
              "Last claim fee at"
            ],
            "type": "i64"
          },
          {
            "name": "lastUpdatedAt",
            "docs": [
              "Last fee drip updated at"
            ],
            "type": "i64"
          },
          {
            "name": "lockedFeeA",
            "docs": [
              "Locked fee a"
            ],
            "type": "u64"
          },
          {
            "name": "lockedFeeB",
            "docs": [
              "Locked fee b"
            ],
            "type": "u64"
          },
          {
            "name": "padding0",
            "docs": [
              "Padding"
            ],
            "type": "u64"
          },
          {
            "name": "cumulativeFeeAPerLiquidity",
            "docs": [
              "cumulative fee a per liquidity"
            ],
            "type": "u128"
          },
          {
            "name": "cumulativeFeeBPerLiquidity",
            "docs": [
              "cumulative fee b per liquidity"
            ],
            "type": "u128"
          },
          {
            "name": "padding",
            "docs": [
              "padding"
            ],
            "type": {
              "array": [
                "u128",
                4
              ]
            }
          }
        ]
      }
    },
    {
      "name": "Rounding",
      "docs": [
        "Round up, down"
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Up"
          },
          {
            "name": "Down"
          }
        ]
      }
    }
  ],
  "events": [
    {
      "name": "VaultCreated",
      "fields": [
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "tokenAMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "tokenBMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "stakeMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "quoteMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "creator",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "topListLength",
          "type": "u16",
          "index": false
        },
        {
          "name": "secondsToFullUnlock",
          "type": "u64",
          "index": false
        },
        {
          "name": "unstakeLockDuration",
          "type": "u64",
          "index": false
        },
        {
          "name": "startFeeDistributeTimestamp",
          "type": "i64",
          "index": false
        }
      ]
    },
    {
      "name": "StakeEscrowCreated",
      "fields": [
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "escrow",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "fullBalanceIndex",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "ConfigCreated",
      "fields": [
        {
          "name": "config",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "index",
          "type": "u64",
          "index": false
        },
        {
          "name": "secondsToFullUnlock",
          "type": "u64",
          "index": false
        },
        {
          "name": "unstakeLockDuration",
          "type": "u64",
          "index": false
        },
        {
          "name": "joinWindowDuration",
          "type": "u64",
          "index": false
        },
        {
          "name": "topListLength",
          "type": "u16",
          "index": false
        }
      ]
    },
    {
      "name": "ConfigClosed",
      "fields": [
        {
          "name": "config",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "index",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "UnstakeCreated",
      "fields": [
        {
          "name": "unstake",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        },
        {
          "name": "newStakeEscrowAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "newStakeEscrowOngoingTotalUnstakeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeBPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        },
        {
          "name": "feeBPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        },
        {
          "name": "startAt",
          "type": "i64",
          "index": false
        },
        {
          "name": "endAt",
          "type": "i64",
          "index": false
        }
      ]
    },
    {
      "name": "CancelUnstakeSucceed",
      "fields": [
        {
          "name": "unstake",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        },
        {
          "name": "newStakeEscrowAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "newStakeEscrowOngoingTotalUnstakeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeBPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        },
        {
          "name": "feeBPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        }
      ]
    },
    {
      "name": "WithdrawSucceed",
      "fields": [
        {
          "name": "unstake",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        },
        {
          "name": "newStakeEscrowOngoingTotalUnstakeAmount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "ClaimFeeSucceed",
      "fields": [
        {
          "name": "stakeEscrow",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "feeAAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeBAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "totalFeeAAmount",
          "type": "u128",
          "index": false
        },
        {
          "name": "totalFeeBAmount",
          "type": "u128",
          "index": false
        }
      ]
    },
    {
      "name": "FeeEmission",
      "fields": [
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "tokenAClaimed",
          "type": "u64",
          "index": false
        },
        {
          "name": "tokenBClaimed",
          "type": "u64",
          "index": false
        },
        {
          "name": "tokenAReleased",
          "type": "u64",
          "index": false
        },
        {
          "name": "tokenBReleased",
          "type": "u64",
          "index": false
        },
        {
          "name": "cumulativeFeeAPerLiquidity",
          "type": "u128",
          "index": false
        },
        {
          "name": "cumulativeFeeBPerLiquidity",
          "type": "u128",
          "index": false
        },
        {
          "name": "effectiveStakeAmount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "AddNewUserToTopHolder",
      "fields": [
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "stakeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeBPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        },
        {
          "name": "feeBPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        }
      ]
    },
    {
      "name": "RemoveUserFromTopHolder",
      "fields": [
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "stakeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeBPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        },
        {
          "name": "feeBPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        }
      ]
    },
    {
      "name": "UserStake",
      "fields": [
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "stakeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "totalStakeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeBPending",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeAPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        },
        {
          "name": "feeBPerLiquidityCheckpoint",
          "type": "u128",
          "index": false
        }
      ]
    },
    {
      "name": "ReclaimIndex",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "inOwner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "inOwnerBalance",
          "type": "u64",
          "index": false
        },
        {
          "name": "outOwner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "outOwnerBalance",
          "type": "u64",
          "index": false
        },
        {
          "name": "reclaimIndex",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "UpdateUnstakeLockDuration",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "oldValue",
          "type": "u64",
          "index": false
        },
        {
          "name": "newValue",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "UpdateSecondsToFullUnlock",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "oldValue",
          "type": "u64",
          "index": false
        },
        {
          "name": "newValue",
          "type": "u64",
          "index": false
        }
      ]
    }
  ],
  "errors": [
    {
      "code": 6e3,
      "name": "InvalidEscrowOwner",
      "msg": "Escrow owner is not vault"
    },
    {
      "code": 6001,
      "name": "InvalidTopListLength",
      "msg": "Invalid top list length"
    },
    {
      "code": 6002,
      "name": "InvalidSecondsToFullUnlock",
      "msg": "Invalid seconds to full unlock"
    },
    {
      "code": 6003,
      "name": "MustHaveQuoteTokenOrInvalidStakeMint",
      "msg": "Pool missing SOL/USDC token or invalid stake mint"
    },
    {
      "code": 6004,
      "name": "MissingDroppedStakeEscrow",
      "msg": "Missing dropped stake escrow"
    },
    {
      "code": 6005,
      "name": "InvalidStakeEscrow",
      "msg": "Invalid stake escrow"
    },
    {
      "code": 6006,
      "name": "FullBalanceListFull",
      "msg": "Full balance list is full"
    },
    {
      "code": 6007,
      "name": "MintDoesNotBelongToPool",
      "msg": "Mint does not belong to the pool"
    },
    {
      "code": 6008,
      "name": "InsufficientStakeAmount",
      "msg": "Insufficient stake amount"
    },
    {
      "code": 6009,
      "name": "CannotWithdrawUnstakeAmount",
      "msg": "Unstake amount release date not reached"
    },
    {
      "code": 6010,
      "name": "InvalidAdmin",
      "msg": "Invalid admin"
    },
    {
      "code": 6011,
      "name": "InvalidUnstakeLockDuration",
      "msg": "Invalid unstake lock duration"
    },
    {
      "code": 6012,
      "name": "InvalidJoinWindowDuration",
      "msg": "Invalid join window duration"
    },
    {
      "code": 6013,
      "name": "InvalidCustomStartFeeDistributeTimestamp",
      "msg": "Invalid custom start fee distribute timestamp"
    },
    {
      "code": 6014,
      "name": "InvalidSmallestStakeEscrow",
      "msg": "Invalid smallest stake escrow"
    },
    {
      "code": 6015,
      "name": "MathOverflow",
      "msg": "MathOverflow"
    },
    {
      "code": 6016,
      "name": "TypeCastFailed",
      "msg": "Type casting failed"
    },
    {
      "code": 6017,
      "name": "InvalidLockEscrowRelatedAccounts",
      "msg": "Invalid lock escrow related accounts"
    },
    {
      "code": 6018,
      "name": "OnlyConstantProductPool",
      "msg": "Only constant product pool is supported"
    },
    {
      "code": 6019,
      "name": "UndeterminedError",
      "msg": "Undetermined error"
    },
    {
      "code": 6020,
      "name": "MissingSmallestStakeEscrow",
      "msg": "Missing smallest stake escrow"
    },
    {
      "code": 6021,
      "name": "UpdatedValueIsTheSame",
      "msg": "Updated value is the same as old value"
    },
    {
      "code": 6022,
      "name": "InvalidFeeCrankIx",
      "msg": "Invalid fee crank instruction"
    }
  ]
};

// src/stake-for-fee/idls/dynamic_amm.ts
var IDL2 = {
  version: "0.5.1",
  name: "amm",
  docs: ["Program for AMM"],
  instructions: [
    {
      name: "initializePermissionedPool",
      docs: ["Initialize a new permissioned pool."],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: true,
          docs: ["Pool account (arbitrary address)"]
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "tokenAMint",
          isMut: false,
          isSigner: false,
          docs: ["Token A mint of the pool. Eg: USDT"]
        },
        {
          name: "tokenBMint",
          isMut: false,
          isSigner: false,
          docs: ["Token B mint of the pool. Eg: USDC"]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault A"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault B"]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "adminTokenA",
          isMut: true,
          isSigner: false,
          docs: [
            "Admin token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "adminTokenB",
          isMut: true,
          isSigner: false,
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "adminPoolLp",
          isMut: true,
          isSigner: false,
          docs: [
            "Admin pool LP token account. Used to receive LP during first deposit (initialize pool)",
            "Admin pool LP token account. Used to receive LP during first deposit (initialize pool)"
          ]
        },
        {
          name: "protocolTokenAFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ]
        },
        {
          name: "protocolTokenBFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ]
        },
        {
          name: "admin",
          isMut: true,
          isSigner: true,
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ]
        },
        {
          name: "feeOwner",
          isMut: false,
          isSigner: false
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false,
          docs: ["Rent account."]
        },
        {
          name: "mintMetadata",
          isMut: true,
          isSigner: false
        },
        {
          name: "metadataProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Associated token program."]
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false,
          docs: ["System program."]
        }
      ],
      args: [
        {
          name: "curveType",
          type: {
            defined: "CurveType"
          }
        }
      ]
    },
    {
      name: "initializePermissionlessPool",
      docs: ["Initialize a new permissionless pool."],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA address)"]
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "tokenAMint",
          isMut: false,
          isSigner: false,
          docs: ["Token A mint of the pool. Eg: USDT"]
        },
        {
          name: "tokenBMint",
          isMut: false,
          isSigner: false,
          docs: ["Token B mint of the pool. Eg: USDC"]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault A"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault B"]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "payerTokenA",
          isMut: true,
          isSigner: false,
          docs: [
            "Payer token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "payerTokenB",
          isMut: true,
          isSigner: false,
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "payerPoolLp",
          isMut: true,
          isSigner: false
        },
        {
          name: "protocolTokenAFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ]
        },
        {
          name: "protocolTokenBFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ]
        },
        {
          name: "payer",
          isMut: true,
          isSigner: true,
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ]
        },
        {
          name: "feeOwner",
          isMut: false,
          isSigner: false
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false,
          docs: ["Rent account."]
        },
        {
          name: "mintMetadata",
          isMut: true,
          isSigner: false
        },
        {
          name: "metadataProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Associated token program."]
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false,
          docs: ["System program."]
        }
      ],
      args: [
        {
          name: "curveType",
          type: {
            defined: "CurveType"
          }
        },
        {
          name: "tokenAAmount",
          type: "u64"
        },
        {
          name: "tokenBAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "initializePermissionlessPoolWithFeeTier",
      docs: ["Initialize a new permissionless pool with customized fee tier"],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA address)"]
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "tokenAMint",
          isMut: false,
          isSigner: false,
          docs: ["Token A mint of the pool. Eg: USDT"]
        },
        {
          name: "tokenBMint",
          isMut: false,
          isSigner: false,
          docs: ["Token B mint of the pool. Eg: USDC"]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault A"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault B"]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "payerTokenA",
          isMut: true,
          isSigner: false,
          docs: [
            "Payer token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "payerTokenB",
          isMut: true,
          isSigner: false,
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "payerPoolLp",
          isMut: true,
          isSigner: false
        },
        {
          name: "protocolTokenAFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ]
        },
        {
          name: "protocolTokenBFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ]
        },
        {
          name: "payer",
          isMut: true,
          isSigner: true,
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ]
        },
        {
          name: "feeOwner",
          isMut: false,
          isSigner: false
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false,
          docs: ["Rent account."]
        },
        {
          name: "mintMetadata",
          isMut: true,
          isSigner: false
        },
        {
          name: "metadataProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Associated token program."]
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false,
          docs: ["System program."]
        }
      ],
      args: [
        {
          name: "curveType",
          type: {
            defined: "CurveType"
          }
        },
        {
          name: "tradeFeeBps",
          type: "u64"
        },
        {
          name: "tokenAAmount",
          type: "u64"
        },
        {
          name: "tokenBAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "enableOrDisablePool",
      docs: [
        "Enable or disable a pool. A disabled pool allow only remove balanced liquidity operation."
      ],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "admin",
          isMut: false,
          isSigner: true,
          docs: ["Admin account. Must be owner of the pool."]
        }
      ],
      args: [
        {
          name: "enable",
          type: "bool"
        }
      ]
    },
    {
      name: "swap",
      docs: [
        "Swap token A to B, or vice versa. An amount of trading fee will be charged for liquidity provider, and the admin of the pool."
      ],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "userSourceToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token account. Token from this account will be transfer into the vault by the pool in exchange for another token of the pool."
          ]
        },
        {
          name: "userDestinationToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token account. The exchanged token will be transfer into this account from the pool."
          ]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["Lp token mint of vault a"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["Lp token mint of vault b"]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "protocolTokenFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account. Used to receive trading fee. It's mint field must matched with user_source_token mint field."
          ]
        },
        {
          name: "user",
          isMut: false,
          isSigner: true,
          docs: ["User account. Must be owner of user_source_token."]
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        }
      ],
      args: [
        {
          name: "inAmount",
          type: "u64"
        },
        {
          name: "minimumOutAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "removeLiquiditySingleSide",
      docs: [
        "Withdraw only single token from the pool. Only supported by pool with stable swap curve."
      ],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "userPoolLp",
          isMut: true,
          isSigner: false,
          docs: [
            "User pool lp token account. LP will be burned from this account upon success liquidity removal."
          ]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault A"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault B"]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "userDestinationToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token account to receive token upon success liquidity removal."
          ]
        },
        {
          name: "user",
          isMut: false,
          isSigner: true,
          docs: ["User account. Must be owner of the user_pool_lp account."]
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        }
      ],
      args: [
        {
          name: "poolTokenAmount",
          type: "u64"
        },
        {
          name: "minimumOutAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "addImbalanceLiquidity",
      docs: [
        "Deposit tokens to the pool in an imbalance ratio. Only supported by pool with stable swap curve."
      ],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "userPoolLp",
          isMut: true,
          isSigner: false,
          docs: [
            "user pool lp token account. lp will be burned from this account upon success liquidity removal."
          ]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault a"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault b"]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "userAToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "userBToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "user",
          isMut: false,
          isSigner: true,
          docs: [
            "User account. Must be owner of user_a_token, and user_b_token."
          ]
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        }
      ],
      args: [
        {
          name: "minimumPoolTokenAmount",
          type: "u64"
        },
        {
          name: "tokenAAmount",
          type: "u64"
        },
        {
          name: "tokenBAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "removeBalanceLiquidity",
      docs: [
        "Withdraw tokens from the pool in a balanced ratio. User will still able to withdraw from pool even the pool is disabled. This allow user to exit their liquidity when there's some unforeseen event happen."
      ],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "userPoolLp",
          isMut: true,
          isSigner: false,
          docs: [
            "user pool lp token account. lp will be burned from this account upon success liquidity removal."
          ]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault a"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault b"]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "userAToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "userBToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "user",
          isMut: false,
          isSigner: true,
          docs: [
            "User account. Must be owner of user_a_token, and user_b_token."
          ]
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        }
      ],
      args: [
        {
          name: "poolTokenAmount",
          type: "u64"
        },
        {
          name: "minimumATokenOut",
          type: "u64"
        },
        {
          name: "minimumBTokenOut",
          type: "u64"
        }
      ]
    },
    {
      name: "addBalanceLiquidity",
      docs: ["Deposit tokens to the pool in a balanced ratio."],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "userPoolLp",
          isMut: true,
          isSigner: false,
          docs: [
            "user pool lp token account. lp will be burned from this account upon success liquidity removal."
          ]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault a"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault b"]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "userAToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "userBToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "user",
          isMut: false,
          isSigner: true,
          docs: [
            "User account. Must be owner of user_a_token, and user_b_token."
          ]
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        }
      ],
      args: [
        {
          name: "poolTokenAmount",
          type: "u64"
        },
        {
          name: "maximumTokenAAmount",
          type: "u64"
        },
        {
          name: "maximumTokenBAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "setPoolFees",
      docs: ["Update trading fee charged for liquidity provider, and admin."],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "feeOperator",
          isMut: false,
          isSigner: true,
          docs: ["Fee operator account"]
        }
      ],
      args: [
        {
          name: "fees",
          type: {
            defined: "PoolFees"
          }
        }
      ]
    },
    {
      name: "overrideCurveParam",
      docs: [
        "Update swap curve parameters. This function do not allow update of curve type. For example: stable swap curve to constant product curve. Only supported by pool with stable swap curve.",
        "Only amp is allowed to be override. The other attributes of stable swap curve will be ignored."
      ],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "admin",
          isMut: false,
          isSigner: true,
          docs: ["Admin account."]
        }
      ],
      args: [
        {
          name: "curveType",
          type: {
            defined: "CurveType"
          }
        }
      ]
    },
    {
      name: "getPoolInfo",
      docs: ["Get the general information of the pool."],
      accounts: [
        {
          name: "pool",
          isMut: false,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "lpMint",
          isMut: false,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "aVaultLp",
          isMut: false,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: false,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "aVault",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aVaultLpMint",
          isMut: false,
          isSigner: false,
          docs: ["LP token mint of vault a"]
        },
        {
          name: "bVaultLpMint",
          isMut: false,
          isSigner: false,
          docs: ["LP token mint of vault b"]
        }
      ],
      args: []
    },
    {
      name: "bootstrapLiquidity",
      docs: ["Bootstrap the pool when liquidity is depleted."],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "userPoolLp",
          isMut: true,
          isSigner: false,
          docs: [
            "user pool lp token account. lp will be burned from this account upon success liquidity removal."
          ]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault a"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault b"]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "userAToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "userBToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "user",
          isMut: false,
          isSigner: true,
          docs: [
            "User account. Must be owner of user_a_token, and user_b_token."
          ]
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        }
      ],
      args: [
        {
          name: "tokenAAmount",
          type: "u64"
        },
        {
          name: "tokenBAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "createMintMetadata",
      docs: ["Create mint metadata account for old pools"],
      accounts: [
        {
          name: "pool",
          isMut: false,
          isSigner: false,
          docs: ["Pool account"]
        },
        {
          name: "lpMint",
          isMut: false,
          isSigner: false,
          docs: ["LP mint account of the pool"]
        },
        {
          name: "aVaultLp",
          isMut: false,
          isSigner: false,
          docs: ["Vault A LP account of the pool"]
        },
        {
          name: "mintMetadata",
          isMut: true,
          isSigner: false
        },
        {
          name: "metadataProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false,
          docs: ["System program."]
        },
        {
          name: "payer",
          isMut: true,
          isSigner: true,
          docs: ["Payer"]
        }
      ],
      args: []
    },
    {
      name: "createLockEscrow",
      docs: ["Create lock account"],
      accounts: [
        {
          name: "pool",
          isMut: false,
          isSigner: false,
          docs: ["Pool account"]
        },
        {
          name: "lockEscrow",
          isMut: true,
          isSigner: false,
          docs: ["Lock account"]
        },
        {
          name: "owner",
          isMut: false,
          isSigner: false
        },
        {
          name: "lpMint",
          isMut: false,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "payer",
          isMut: true,
          isSigner: true,
          docs: ["Payer account"]
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false,
          docs: ["System program."]
        }
      ],
      args: []
    },
    {
      name: "lock",
      docs: ["Lock Lp token"],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account"]
        },
        {
          name: "lpMint",
          isMut: false,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "lockEscrow",
          isMut: true,
          isSigner: false,
          docs: ["Lock account"]
        },
        {
          name: "owner",
          isMut: true,
          isSigner: true,
          docs: ["Can be anyone"]
        },
        {
          name: "sourceTokens",
          isMut: true,
          isSigner: false,
          docs: ["owner lp token account"]
        },
        {
          name: "escrowVault",
          isMut: true,
          isSigner: false,
          docs: ["Escrow vault"]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        },
        {
          name: "aVault",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aVaultLp",
          isMut: false,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: false,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "aVaultLpMint",
          isMut: false,
          isSigner: false,
          docs: ["LP token mint of vault a"]
        },
        {
          name: "bVaultLpMint",
          isMut: false,
          isSigner: false,
          docs: ["LP token mint of vault b"]
        }
      ],
      args: [
        {
          name: "maxAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "claimFee",
      docs: ["Claim fee"],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account"]
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "lockEscrow",
          isMut: true,
          isSigner: false,
          docs: ["Lock account"]
        },
        {
          name: "owner",
          isMut: true,
          isSigner: true,
          docs: ["Owner of lock account"]
        },
        {
          name: "sourceTokens",
          isMut: true,
          isSigner: false,
          docs: ["owner lp token account"]
        },
        {
          name: "escrowVault",
          isMut: true,
          isSigner: false,
          docs: ["Escrow vault"]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault a"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault b"]
        },
        {
          name: "userAToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "userBToken",
          isMut: true,
          isSigner: false,
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ]
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        }
      ],
      args: [
        {
          name: "maxAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "createConfig",
      docs: ["Create config"],
      accounts: [
        {
          name: "config",
          isMut: true,
          isSigner: false
        },
        {
          name: "admin",
          isMut: true,
          isSigner: true
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "configParameters",
          type: {
            defined: "ConfigParameters"
          }
        }
      ]
    },
    {
      name: "closeConfig",
      docs: ["Close config"],
      accounts: [
        {
          name: "config",
          isMut: true,
          isSigner: false
        },
        {
          name: "admin",
          isMut: true,
          isSigner: true
        },
        {
          name: "rentReceiver",
          isMut: true,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "initializePermissionlessConstantProductPoolWithConfig",
      docs: ["Initialize permissionless pool with config"],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA address)"]
        },
        {
          name: "config",
          isMut: false,
          isSigner: false
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "tokenAMint",
          isMut: false,
          isSigner: false,
          docs: ["Token A mint of the pool. Eg: USDT"]
        },
        {
          name: "tokenBMint",
          isMut: false,
          isSigner: false,
          docs: ["Token B mint of the pool. Eg: USDC"]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault A"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault B"]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "payerTokenA",
          isMut: true,
          isSigner: false,
          docs: [
            "Payer token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "payerTokenB",
          isMut: true,
          isSigner: false,
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "payerPoolLp",
          isMut: true,
          isSigner: false
        },
        {
          name: "protocolTokenAFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ]
        },
        {
          name: "protocolTokenBFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ]
        },
        {
          name: "payer",
          isMut: true,
          isSigner: true,
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ]
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false,
          docs: ["Rent account."]
        },
        {
          name: "mintMetadata",
          isMut: true,
          isSigner: false
        },
        {
          name: "metadataProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Associated token program."]
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false,
          docs: ["System program."]
        }
      ],
      args: [
        {
          name: "tokenAAmount",
          type: "u64"
        },
        {
          name: "tokenBAmount",
          type: "u64"
        }
      ]
    },
    {
      name: "initializePermissionlessConstantProductPoolWithConfig2",
      docs: ["Initialize permissionless pool with config 2"],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA address)"]
        },
        {
          name: "config",
          isMut: false,
          isSigner: false
        },
        {
          name: "lpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of the pool"]
        },
        {
          name: "tokenAMint",
          isMut: false,
          isSigner: false,
          docs: ["Token A mint of the pool. Eg: USDT"]
        },
        {
          name: "tokenBMint",
          isMut: false,
          isSigner: false,
          docs: ["Token B mint of the pool. Eg: USDC"]
        },
        {
          name: "aVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "bVault",
          isMut: true,
          isSigner: false,
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "aTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault A"]
        },
        {
          name: "bTokenVault",
          isMut: true,
          isSigner: false,
          docs: ["Token vault account of vault B"]
        },
        {
          name: "aVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault A"]
        },
        {
          name: "bVaultLpMint",
          isMut: true,
          isSigner: false,
          docs: ["LP token mint of vault B"]
        },
        {
          name: "aVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "bVaultLp",
          isMut: true,
          isSigner: false,
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "payerTokenA",
          isMut: true,
          isSigner: false,
          docs: [
            "Payer token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "payerTokenB",
          isMut: true,
          isSigner: false,
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ]
        },
        {
          name: "payerPoolLp",
          isMut: true,
          isSigner: false
        },
        {
          name: "protocolTokenAFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ]
        },
        {
          name: "protocolTokenBFee",
          isMut: true,
          isSigner: false,
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ]
        },
        {
          name: "payer",
          isMut: true,
          isSigner: true,
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ]
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false,
          docs: ["Rent account."]
        },
        {
          name: "mintMetadata",
          isMut: true,
          isSigner: false
        },
        {
          name: "metadataProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "vaultProgram",
          isMut: false,
          isSigner: false,
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Token program."]
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false,
          docs: ["Associated token program."]
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false,
          docs: ["System program."]
        }
      ],
      args: [
        {
          name: "tokenAAmount",
          type: "u64"
        },
        {
          name: "tokenBAmount",
          type: "u64"
        },
        {
          name: "activationPoint",
          type: {
            option: "u64"
          }
        }
      ]
    },
    {
      name: "updateActivationPoint",
      docs: ["Update activation slot"],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "admin",
          isMut: false,
          isSigner: true,
          docs: ["Admin account."]
        }
      ],
      args: [
        {
          name: "newActivationPoint",
          type: "u64"
        }
      ]
    },
    {
      name: "withdrawProtocolFees",
      docs: ["Withdraw protocol fee"],
      accounts: [
        {
          name: "pool",
          isMut: false,
          isSigner: false,
          docs: ["Pool account (PDA)"]
        },
        {
          name: "aVaultLp",
          isMut: false,
          isSigner: false
        },
        {
          name: "protocolTokenAFee",
          isMut: true,
          isSigner: false
        },
        {
          name: "protocolTokenBFee",
          isMut: true,
          isSigner: false
        },
        {
          name: "treasuryTokenA",
          isMut: true,
          isSigner: false
        },
        {
          name: "treasuryTokenB",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "setWhitelistedVault",
      docs: ["Set whitelisted vault"],
      accounts: [
        {
          name: "pool",
          isMut: true,
          isSigner: false
        },
        {
          name: "admin",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "whitelistedVault",
          type: "publicKey"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "config",
      type: {
        kind: "struct",
        fields: [
          {
            name: "poolFees",
            type: {
              defined: "PoolFees"
            }
          },
          {
            name: "activationDuration",
            type: "u64"
          },
          {
            name: "vaultConfigKey",
            type: "publicKey"
          },
          {
            name: "poolCreatorAuthority",
            type: "publicKey"
          },
          {
            name: "activationType",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: ["u8", 227]
            }
          }
        ]
      }
    },
    {
      name: "lockEscrow",
      docs: ["State of lock escrow account"],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            docs: ["Pool address"],
            type: "publicKey"
          },
          {
            name: "owner",
            docs: ["Owner address"],
            type: "publicKey"
          },
          {
            name: "escrowVault",
            docs: ["Vault address, store the lock user lock"],
            type: "publicKey"
          },
          {
            name: "bump",
            docs: ["bump, used to sign"],
            type: "u8"
          },
          {
            name: "totalLockedAmount",
            docs: ["Total locked amount"],
            type: "u64"
          },
          {
            name: "lpPerToken",
            docs: ["Lp per token, virtual price of lp token"],
            type: "u128"
          },
          {
            name: "unclaimedFeePending",
            docs: ["Unclaimed fee pending"],
            type: "u64"
          },
          {
            name: "aFee",
            docs: ["Total a fee claimed so far"],
            type: "u64"
          },
          {
            name: "bFee",
            docs: ["Total b fee claimed so far"],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "pool",
      docs: ["State of pool account"],
      type: {
        kind: "struct",
        fields: [
          {
            name: "lpMint",
            docs: ["LP token mint of the pool"],
            type: "publicKey"
          },
          {
            name: "tokenAMint",
            docs: ["Token A mint of the pool. Eg: USDT"],
            type: "publicKey"
          },
          {
            name: "tokenBMint",
            docs: ["Token B mint of the pool. Eg: USDC"],
            type: "publicKey"
          },
          {
            name: "aVault",
            docs: [
              "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
            ],
            type: "publicKey"
          },
          {
            name: "bVault",
            docs: [
              "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
            ],
            type: "publicKey"
          },
          {
            name: "aVaultLp",
            docs: [
              "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
            ],
            type: "publicKey"
          },
          {
            name: "bVaultLp",
            docs: [
              "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
            ],
            type: "publicKey"
          },
          {
            name: "aVaultLpBump",
            docs: ['"A" vault lp bump. Used to create signer seeds.'],
            type: "u8"
          },
          {
            name: "enabled",
            docs: [
              "Flag to determine whether the pool is enabled, or disabled."
            ],
            type: "bool"
          },
          {
            name: "protocolTokenAFee",
            docs: [
              "Protocol fee token account for token A. Used to receive trading fee."
            ],
            type: "publicKey"
          },
          {
            name: "protocolTokenBFee",
            docs: [
              "Protocol fee token account for token B. Used to receive trading fee."
            ],
            type: "publicKey"
          },
          {
            name: "feeLastUpdatedAt",
            docs: ["Fee last updated timestamp"],
            type: "u64"
          },
          {
            name: "padding0",
            type: {
              array: ["u8", 24]
            }
          },
          {
            name: "fees",
            docs: ["Store the fee charges setting."],
            type: {
              defined: "PoolFees"
            }
          },
          {
            name: "poolType",
            docs: ["Pool type"],
            type: {
              defined: "PoolType"
            }
          },
          {
            name: "stake",
            docs: ["Stake pubkey of SPL stake pool"],
            type: "publicKey"
          },
          {
            name: "totalLockedLp",
            docs: ["Total locked lp token"],
            type: "u64"
          },
          {
            name: "bootstrapping",
            docs: ["bootstrapping config"],
            type: {
              defined: "Bootstrapping"
            }
          },
          {
            name: "padding",
            docs: ["Padding for future pool field"],
            type: {
              defined: "Padding"
            }
          },
          {
            name: "curveType",
            docs: ["The type of the swap curve supported by the pool."],
            type: {
              defined: "CurveType"
            }
          }
        ]
      }
    }
  ],
  types: [
    {
      name: "TokenMultiplier",
      docs: [
        "Multiplier for the pool token. Used to normalized token with different decimal into the same precision."
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "tokenAMultiplier",
            docs: ["Multiplier for token A of the pool."],
            type: "u64"
          },
          {
            name: "tokenBMultiplier",
            docs: ["Multiplier for token B of the pool."],
            type: "u64"
          },
          {
            name: "precisionFactor",
            docs: [
              "Record the highest token decimal in the pool. For example, Token A is 6 decimal, token B is 9 decimal. This will save value of 9."
            ],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "PoolFees",
      docs: ["Information regarding fee charges"],
      type: {
        kind: "struct",
        fields: [
          {
            name: "tradeFeeNumerator",
            docs: [
              "Trade fees are extra token amounts that are held inside the token",
              "accounts during a trade, making the value of liquidity tokens rise.",
              "Trade fee numerator"
            ],
            type: "u64"
          },
          {
            name: "tradeFeeDenominator",
            docs: ["Trade fee denominator"],
            type: "u64"
          },
          {
            name: "protocolTradeFeeNumerator",
            docs: [
              "Protocol trading fees are extra token amounts that are held inside the token",
              "accounts during a trade, with the equivalent in pool tokens minted to",
              "the protocol of the program.",
              "Protocol trade fee numerator"
            ],
            type: "u64"
          },
          {
            name: "protocolTradeFeeDenominator",
            docs: ["Protocol trade fee denominator"],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Depeg",
      docs: ["Contains information for depeg pool"],
      type: {
        kind: "struct",
        fields: [
          {
            name: "baseVirtualPrice",
            docs: ["The virtual price of staking / interest bearing token"],
            type: "u64"
          },
          {
            name: "baseCacheUpdated",
            docs: ["The last time base_virtual_price is updated"],
            type: "u64"
          },
          {
            name: "depegType",
            docs: ["Type of the depeg pool"],
            type: {
              defined: "DepegType"
            }
          }
        ]
      }
    },
    {
      name: "ConfigParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "tradeFeeNumerator",
            type: "u64"
          },
          {
            name: "protocolTradeFeeNumerator",
            type: "u64"
          },
          {
            name: "activationDuration",
            type: "u64"
          },
          {
            name: "vaultConfigKey",
            type: "publicKey"
          },
          {
            name: "poolCreatorAuthority",
            type: "publicKey"
          },
          {
            name: "activationType",
            type: "u8"
          },
          {
            name: "index",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Padding",
      docs: ["Padding for future pool fields"],
      type: {
        kind: "struct",
        fields: [
          {
            name: "padding0",
            docs: ["Padding 0"],
            type: {
              array: ["u8", 14]
            }
          },
          {
            name: "padding",
            docs: ["Padding 1"],
            type: {
              array: ["u128", 24]
            }
          }
        ]
      }
    },
    {
      name: "Bootstrapping",
      type: {
        kind: "struct",
        fields: [
          {
            name: "activationPoint",
            docs: ["Activation point, can be slot or timestamp"],
            type: "u64"
          },
          {
            name: "whitelistedVault",
            docs: [
              "Whitelisted vault to be able to buy pool before activation_point"
            ],
            type: "publicKey"
          },
          {
            name: "poolCreator",
            docs: [
              "Need to store pool creator in lauch pool, so they can modify liquidity before activation_point"
            ],
            type: "publicKey"
          },
          {
            name: "activationType",
            docs: ["Activation type, 0 means by slot, 1 means by timestamp"],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "ActivationType",
      docs: ["Type of the activation"],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Slot"
          },
          {
            name: "Timestamp"
          }
        ]
      }
    },
    {
      name: "RoundDirection",
      docs: ["Rounding direction"],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Floor"
          },
          {
            name: "Ceiling"
          }
        ]
      }
    },
    {
      name: "TradeDirection",
      docs: ["Trade (swap) direction"],
      type: {
        kind: "enum",
        variants: [
          {
            name: "AtoB"
          },
          {
            name: "BtoA"
          }
        ]
      }
    },
    {
      name: "NewCurveType",
      docs: ["Type of the swap curve"],
      type: {
        kind: "enum",
        variants: [
          {
            name: "ConstantProduct"
          },
          {
            name: "Stable",
            fields: [
              {
                name: "amp",
                docs: ["Amplification coefficient"],
                type: "u64"
              },
              {
                name: "token_multiplier",
                docs: [
                  "Multiplier for the pool token. Used to normalized token with different decimal into the same precision."
                ],
                type: {
                  defined: "TokenMultiplier"
                }
              },
              {
                name: "depeg",
                docs: [
                  "Depeg pool information. Contains functions to allow token amount to be repeg using stake / interest bearing token virtual price"
                ],
                type: {
                  defined: "Depeg"
                }
              },
              {
                name: "last_amp_updated_timestamp",
                docs: [
                  "The last amp updated timestamp. Used to prevent update_curve_info called infinitely many times within a short period"
                ],
                type: "u64"
              }
            ]
          },
          {
            name: "NewCurve",
            fields: [
              {
                name: "field_one",
                type: "u64"
              },
              {
                name: "field_two",
                type: "u64"
              }
            ]
          }
        ]
      }
    },
    {
      name: "CurveType",
      docs: ["Type of the swap curve"],
      type: {
        kind: "enum",
        variants: [
          {
            name: "ConstantProduct"
          },
          {
            name: "Stable",
            fields: [
              {
                name: "amp",
                docs: ["Amplification coefficient"],
                type: "u64"
              },
              {
                name: "token_multiplier",
                docs: [
                  "Multiplier for the pool token. Used to normalized token with different decimal into the same precision."
                ],
                type: {
                  defined: "TokenMultiplier"
                }
              },
              {
                name: "depeg",
                docs: [
                  "Depeg pool information. Contains functions to allow token amount to be repeg using stake / interest bearing token virtual price"
                ],
                type: {
                  defined: "Depeg"
                }
              },
              {
                name: "last_amp_updated_timestamp",
                docs: [
                  "The last amp updated timestamp. Used to prevent update_curve_info called infinitely many times within a short period"
                ],
                type: "u64"
              }
            ]
          }
        ]
      }
    },
    {
      name: "DepegType",
      docs: ["Type of depeg pool"],
      type: {
        kind: "enum",
        variants: [
          {
            name: "None"
          },
          {
            name: "Marinade"
          },
          {
            name: "Lido"
          },
          {
            name: "SplStake"
          }
        ]
      }
    },
    {
      name: "Rounding",
      docs: ["Round up, down"],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Up"
          },
          {
            name: "Down"
          }
        ]
      }
    },
    {
      name: "PoolType",
      docs: ["Pool type"],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Permissioned"
          },
          {
            name: "Permissionless"
          }
        ]
      }
    }
  ],
  events: [
    {
      name: "AddLiquidity",
      fields: [
        {
          name: "lpMintAmount",
          type: "u64",
          index: false
        },
        {
          name: "tokenAAmount",
          type: "u64",
          index: false
        },
        {
          name: "tokenBAmount",
          type: "u64",
          index: false
        }
      ]
    },
    {
      name: "RemoveLiquidity",
      fields: [
        {
          name: "lpUnmintAmount",
          type: "u64",
          index: false
        },
        {
          name: "tokenAOutAmount",
          type: "u64",
          index: false
        },
        {
          name: "tokenBOutAmount",
          type: "u64",
          index: false
        }
      ]
    },
    {
      name: "BootstrapLiquidity",
      fields: [
        {
          name: "lpMintAmount",
          type: "u64",
          index: false
        },
        {
          name: "tokenAAmount",
          type: "u64",
          index: false
        },
        {
          name: "tokenBAmount",
          type: "u64",
          index: false
        },
        {
          name: "pool",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "Swap",
      fields: [
        {
          name: "inAmount",
          type: "u64",
          index: false
        },
        {
          name: "outAmount",
          type: "u64",
          index: false
        },
        {
          name: "tradeFee",
          type: "u64",
          index: false
        },
        {
          name: "protocolFee",
          type: "u64",
          index: false
        },
        {
          name: "hostFee",
          type: "u64",
          index: false
        }
      ]
    },
    {
      name: "SetPoolFees",
      fields: [
        {
          name: "tradeFeeNumerator",
          type: "u64",
          index: false
        },
        {
          name: "tradeFeeDenominator",
          type: "u64",
          index: false
        },
        {
          name: "protocolTradeFeeNumerator",
          type: "u64",
          index: false
        },
        {
          name: "protocolTradeFeeDenominator",
          type: "u64",
          index: false
        },
        {
          name: "pool",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "PoolInfo",
      fields: [
        {
          name: "tokenAAmount",
          type: "u64",
          index: false
        },
        {
          name: "tokenBAmount",
          type: "u64",
          index: false
        },
        {
          name: "virtualPrice",
          type: "f64",
          index: false
        },
        {
          name: "currentTimestamp",
          type: "u64",
          index: false
        }
      ]
    },
    {
      name: "TransferAdmin",
      fields: [
        {
          name: "admin",
          type: "publicKey",
          index: false
        },
        {
          name: "newAdmin",
          type: "publicKey",
          index: false
        },
        {
          name: "pool",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "OverrideCurveParam",
      fields: [
        {
          name: "newAmp",
          type: "u64",
          index: false
        },
        {
          name: "updatedTimestamp",
          type: "u64",
          index: false
        },
        {
          name: "pool",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "PoolCreated",
      fields: [
        {
          name: "lpMint",
          type: "publicKey",
          index: false
        },
        {
          name: "tokenAMint",
          type: "publicKey",
          index: false
        },
        {
          name: "tokenBMint",
          type: "publicKey",
          index: false
        },
        {
          name: "poolType",
          type: {
            defined: "PoolType"
          },
          index: false
        },
        {
          name: "pool",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "PoolEnabled",
      fields: [
        {
          name: "pool",
          type: "publicKey",
          index: false
        },
        {
          name: "enabled",
          type: "bool",
          index: false
        }
      ]
    },
    {
      name: "MigrateFeeAccount",
      fields: [
        {
          name: "pool",
          type: "publicKey",
          index: false
        },
        {
          name: "newAdminTokenAFee",
          type: "publicKey",
          index: false
        },
        {
          name: "newAdminTokenBFee",
          type: "publicKey",
          index: false
        },
        {
          name: "tokenAAmount",
          type: "u64",
          index: false
        },
        {
          name: "tokenBAmount",
          type: "u64",
          index: false
        }
      ]
    },
    {
      name: "CreateLockEscrow",
      fields: [
        {
          name: "pool",
          type: "publicKey",
          index: false
        },
        {
          name: "owner",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "Lock",
      fields: [
        {
          name: "pool",
          type: "publicKey",
          index: false
        },
        {
          name: "owner",
          type: "publicKey",
          index: false
        },
        {
          name: "amount",
          type: "u64",
          index: false
        }
      ]
    },
    {
      name: "ClaimFee",
      fields: [
        {
          name: "pool",
          type: "publicKey",
          index: false
        },
        {
          name: "owner",
          type: "publicKey",
          index: false
        },
        {
          name: "amount",
          type: "u64",
          index: false
        },
        {
          name: "aFee",
          type: "u64",
          index: false
        },
        {
          name: "bFee",
          type: "u64",
          index: false
        }
      ]
    },
    {
      name: "CreateConfig",
      fields: [
        {
          name: "tradeFeeNumerator",
          type: "u64",
          index: false
        },
        {
          name: "protocolTradeFeeNumerator",
          type: "u64",
          index: false
        },
        {
          name: "config",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "CloseConfig",
      fields: [
        {
          name: "config",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "WithdrawProtocolFees",
      fields: [
        {
          name: "pool",
          type: "publicKey",
          index: false
        },
        {
          name: "protocolAFee",
          type: "u64",
          index: false
        },
        {
          name: "protocolBFee",
          type: "u64",
          index: false
        },
        {
          name: "protocolAFeeOwner",
          type: "publicKey",
          index: false
        },
        {
          name: "protocolBFeeOwner",
          type: "publicKey",
          index: false
        }
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "MathOverflow",
      msg: "Math operation overflow"
    },
    {
      code: 6001,
      name: "InvalidFee",
      msg: "Invalid fee setup"
    },
    {
      code: 6002,
      name: "InvalidInvariant",
      msg: "Invalid invariant d"
    },
    {
      code: 6003,
      name: "FeeCalculationFailure",
      msg: "Fee calculation failure"
    },
    {
      code: 6004,
      name: "ExceededSlippage",
      msg: "Exceeded slippage tolerance"
    },
    {
      code: 6005,
      name: "InvalidCalculation",
      msg: "Invalid curve calculation"
    },
    {
      code: 6006,
      name: "ZeroTradingTokens",
      msg: "Given pool token amount results in zero trading tokens"
    },
    {
      code: 6007,
      name: "ConversionError",
      msg: "Math conversion overflow"
    },
    {
      code: 6008,
      name: "FaultyLpMint",
      msg: "LP mint authority must be 'A' vault lp, without freeze authority, and 0 supply"
    },
    {
      code: 6009,
      name: "MismatchedTokenMint",
      msg: "Token mint mismatched"
    },
    {
      code: 6010,
      name: "MismatchedLpMint",
      msg: "LP mint mismatched"
    },
    {
      code: 6011,
      name: "MismatchedOwner",
      msg: "Invalid lp token owner"
    },
    {
      code: 6012,
      name: "InvalidVaultAccount",
      msg: "Invalid vault account"
    },
    {
      code: 6013,
      name: "InvalidVaultLpAccount",
      msg: "Invalid vault lp account"
    },
    {
      code: 6014,
      name: "InvalidPoolLpMintAccount",
      msg: "Invalid pool lp mint account"
    },
    {
      code: 6015,
      name: "PoolDisabled",
      msg: "Pool disabled"
    },
    {
      code: 6016,
      name: "InvalidAdminAccount",
      msg: "Invalid admin account"
    },
    {
      code: 6017,
      name: "InvalidProtocolFeeAccount",
      msg: "Invalid protocol fee account"
    },
    {
      code: 6018,
      name: "SameAdminAccount",
      msg: "Same admin account"
    },
    {
      code: 6019,
      name: "IdenticalSourceDestination",
      msg: "Identical user source and destination token account"
    },
    {
      code: 6020,
      name: "ApyCalculationError",
      msg: "Apy calculation error"
    },
    {
      code: 6021,
      name: "InsufficientSnapshot",
      msg: "Insufficient virtual price snapshot"
    },
    {
      code: 6022,
      name: "NonUpdatableCurve",
      msg: "Current curve is non-updatable"
    },
    {
      code: 6023,
      name: "MisMatchedCurve",
      msg: "New curve is mismatched with old curve"
    },
    {
      code: 6024,
      name: "InvalidAmplification",
      msg: "Amplification is invalid"
    },
    {
      code: 6025,
      name: "UnsupportedOperation",
      msg: "Operation is not supported"
    },
    {
      code: 6026,
      name: "ExceedMaxAChanges",
      msg: "Exceed max amplification changes"
    },
    {
      code: 6027,
      name: "InvalidRemainingAccountsLen",
      msg: "Invalid remaining accounts length"
    },
    {
      code: 6028,
      name: "InvalidRemainingAccounts",
      msg: "Invalid remaining account"
    },
    {
      code: 6029,
      name: "MismatchedDepegMint",
      msg: "Token mint B doesn't matches depeg type token mint"
    },
    {
      code: 6030,
      name: "InvalidApyAccount",
      msg: "Invalid APY account"
    },
    {
      code: 6031,
      name: "InvalidTokenMultiplier",
      msg: "Invalid token multiplier"
    },
    {
      code: 6032,
      name: "InvalidDepegInformation",
      msg: "Invalid depeg information"
    },
    {
      code: 6033,
      name: "UpdateTimeConstraint",
      msg: "Update time constraint violated"
    },
    {
      code: 6034,
      name: "ExceedMaxFeeBps",
      msg: "Exceeded max fee bps"
    },
    {
      code: 6035,
      name: "InvalidAdmin",
      msg: "Invalid admin"
    },
    {
      code: 6036,
      name: "PoolIsNotPermissioned",
      msg: "Pool is not permissioned"
    },
    {
      code: 6037,
      name: "InvalidDepositAmount",
      msg: "Invalid deposit amount"
    },
    {
      code: 6038,
      name: "InvalidFeeOwner",
      msg: "Invalid fee owner"
    },
    {
      code: 6039,
      name: "NonDepletedPool",
      msg: "Pool is not depleted"
    },
    {
      code: 6040,
      name: "AmountNotPeg",
      msg: "Token amount is not 1:1"
    },
    {
      code: 6041,
      name: "AmountIsZero",
      msg: "Amount is zero"
    },
    {
      code: 6042,
      name: "TypeCastFailed",
      msg: "Type cast error"
    },
    {
      code: 6043,
      name: "AmountIsNotEnough",
      msg: "Amount is not enough"
    },
    {
      code: 6044,
      name: "InvalidActivationDuration",
      msg: "Invalid activation duration"
    },
    {
      code: 6045,
      name: "PoolIsNotLaunchPool",
      msg: "Pool is not launch pool"
    },
    {
      code: 6046,
      name: "UnableToModifyActivationPoint",
      msg: "Unable to modify activation point"
    },
    {
      code: 6047,
      name: "InvalidAuthorityToCreateThePool",
      msg: "Invalid authority to create the pool"
    },
    {
      code: 6048,
      name: "InvalidActivationType",
      msg: "Invalid activation type"
    },
    {
      code: 6049,
      name: "InvalidActivationPoint",
      msg: "Invalid activation point"
    },
    {
      code: 6050,
      name: "PreActivationSwapStarted",
      msg: "Pre activation swap window started"
    },
    {
      code: 6051,
      name: "InvalidPoolType",
      msg: "Invalid pool type"
    }
  ]
};

// src/stake-for-fee/idls/dynamic_vault.ts
var IDL3 = {
  "version": "0.9.1",
  "name": "vault",
  "docs": [
    "Program for vault"
  ],
  "instructions": [
    {
      "name": "initialize",
      "docs": [
        "initialize new vault"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "This is base account for all vault",
            "No need base key now because we only allow 1 vault per token now",
            "Vault account"
          ]
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true,
          "docs": [
            "Payer can be anyone"
          ]
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Token vault account"
          ]
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Token mint account"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "LP mint account"
          ]
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "rent"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "system_program"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "initializeIdleVault",
      "docs": [
        "initialize idle vault the vault that cannot be rebalanced"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true,
          "docs": [
            "Payer can be anyone"
          ]
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Token vault account"
          ]
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Token mint account"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "LP mint"
          ]
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "rent"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "system_program"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "enableVault",
      "docs": [
        "enable vault"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "Admin account"
          ]
        }
      ],
      "args": [
        {
          "name": "enabled",
          "type": "u8"
        }
      ]
    },
    {
      "name": "setOperator",
      "docs": [
        "set new operator"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "operator",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "admin"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "updateLockedProfitDegradation",
      "docs": [
        "update locked profit degradation"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "Admin account"
          ]
        }
      ],
      "args": [
        {
          "name": "lockedProfitDegradation",
          "type": "u64"
        }
      ]
    },
    {
      "name": "getUnlockedAmount",
      "docs": [
        "get unlocked amount"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "transferAdmin",
      "docs": [
        "transfer admin"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "Admin account"
          ]
        },
        {
          "name": "newAdmin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "New vault admin"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "transferFeeVault",
      "docs": [
        "transfer fee account"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "Admin account"
          ]
        },
        {
          "name": "newFeeVault",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "New fee vault account"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "initializeStrategy",
      "docs": [
        "Initialize a strategy and add strategy to vault.strategies index"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "strategyProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "strategy",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Strategy account"
          ]
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "collateralVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Collateral vault account"
          ]
        },
        {
          "name": "collateralMint",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Collateral mint account"
          ]
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true,
          "docs": [
            "Admin account"
          ]
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "System program account"
          ]
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Rent account"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "Token program account"
          ]
        }
      ],
      "args": [
        {
          "name": "bumps",
          "type": {
            "defined": "StrategyBumps"
          }
        },
        {
          "name": "strategyType",
          "type": {
            "defined": "StrategyType"
          }
        }
      ]
    },
    {
      "name": "removeStrategy",
      "docs": [
        "remove a strategy"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "strategy",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Strategy account"
          ]
        },
        {
          "name": "strategyProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "collateralVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Collateral vault account"
          ]
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_vault"
          ]
        },
        {
          "name": "feeVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "fee_vault"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "lp_mint"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "admin"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "removeStrategy2",
      "docs": [
        "remove a strategy by advance payment"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Vault account"
          ]
        },
        {
          "name": "strategy",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Strategy account"
          ]
        },
        {
          "name": "strategyProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "collateralVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Collateral vault account"
          ]
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_vault"
          ]
        },
        {
          "name": "tokenAdminAdvancePayment",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_advance_payemnt",
            "the owner of token_advance_payment must be admin"
          ]
        },
        {
          "name": "tokenVaultAdvancePayment",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_vault_advance_payment",
            "the account must be different from token_vault",
            "the owner of token_advance_payment must be vault"
          ]
        },
        {
          "name": "feeVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "fee_vault"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "lp_mint"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "admin"
          ]
        }
      ],
      "args": [
        {
          "name": "maxAdminPayAmount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "collectDust",
      "docs": [
        "collect token, that someone send wrongly",
        "also help in case Mango reimbursement"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "vault"
          ]
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Token vault, must be different from vault.token_vault"
          ]
        },
        {
          "name": "tokenAdmin",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token admin, enforce owner is admin to avoid mistake"
          ]
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "admin"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "addStrategy",
      "docs": [
        "add a strategy"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "vault"
          ]
        },
        {
          "name": "strategy",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "strategy"
          ]
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "admin"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "depositStrategy",
      "docs": [
        "deposit liquidity to a strategy"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "vault"
          ]
        },
        {
          "name": "strategy",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "strategy"
          ]
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_vault"
          ]
        },
        {
          "name": "feeVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "fee_vault"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "lp_mint"
          ]
        },
        {
          "name": "strategyProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "collateralVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "collateral_vault"
          ]
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        },
        {
          "name": "operator",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "operator"
          ]
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "withdrawStrategy",
      "docs": [
        "withdraw liquidity from a strategy"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "vault"
          ]
        },
        {
          "name": "strategy",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "strategy"
          ]
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_vault"
          ]
        },
        {
          "name": "feeVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "fee_vault"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "lp_mint"
          ]
        },
        {
          "name": "strategyProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "collateralVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "collateral_vault"
          ]
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        },
        {
          "name": "operator",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "operator"
          ]
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "claimRewards",
      "docs": [
        "claim rewards from a strategy"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "vault"
          ]
        },
        {
          "name": "strategy",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "strategy"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        },
        {
          "name": "tokenRewardAcc",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_reward_acc"
          ]
        },
        {
          "name": "operator",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "operator"
          ]
        }
      ],
      "args": []
    },
    {
      "name": "withdraw2",
      "docs": [
        "Withdraw v2. Withdraw from token vault if no remaining accounts are available. Else, it will attempt to withdraw from strategy and token vault. This method just proxy between 2 methods. Protocol integration should be using withdraw instead of this function."
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "vault"
          ]
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_vault"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "lp_mint"
          ]
        },
        {
          "name": "userToken",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "user_token"
          ]
        },
        {
          "name": "userLp",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "user_lp"
          ]
        },
        {
          "name": "user",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "user"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        }
      ],
      "args": [
        {
          "name": "unmintAmount",
          "type": "u64"
        },
        {
          "name": "minOutAmount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "deposit",
      "docs": [
        "user deposit liquidity to vault"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "vault"
          ]
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_vault"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "lp_mint"
          ]
        },
        {
          "name": "userToken",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "user_token"
          ]
        },
        {
          "name": "userLp",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "user_lp"
          ]
        },
        {
          "name": "user",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "user"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        }
      ],
      "args": [
        {
          "name": "tokenAmount",
          "type": "u64"
        },
        {
          "name": "minimumLpTokenAmount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "withdraw",
      "docs": [
        "user withdraw liquidity from vault"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "vault"
          ]
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_vault"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "lp_mint"
          ]
        },
        {
          "name": "userToken",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "user_token"
          ]
        },
        {
          "name": "userLp",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "user_lp"
          ]
        },
        {
          "name": "user",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "user"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        }
      ],
      "args": [
        {
          "name": "unmintAmount",
          "type": "u64"
        },
        {
          "name": "minOutAmount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "withdrawDirectlyFromStrategy",
      "docs": [
        "user withdraw liquidity from vault, if vault reserve doesn't have enough liquidity, it will withdraw from the strategy firstly"
      ],
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "vault"
          ]
        },
        {
          "name": "strategy",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "strategy"
          ]
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "strategyProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "collateralVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "collateral_vault"
          ]
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "token_vault"
          ]
        },
        {
          "name": "lpMint",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "lp_mint"
          ]
        },
        {
          "name": "feeVault",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "fee_vault"
          ]
        },
        {
          "name": "userToken",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "user_token"
          ]
        },
        {
          "name": "userLp",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "user_lp"
          ]
        },
        {
          "name": "user",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "user"
          ]
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "token_program"
          ]
        }
      ],
      "args": [
        {
          "name": "unmintAmount",
          "type": "u64"
        },
        {
          "name": "minOutAmount",
          "type": "u64"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "vault",
      "docs": [
        "Vault struct"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "enabled",
            "docs": [
              "The flag, if admin set enable = false, then the user can only withdraw and cannot deposit in the vault."
            ],
            "type": "u8"
          },
          {
            "name": "bumps",
            "docs": [
              "Vault nonce, to create vault seeds"
            ],
            "type": {
              "defined": "VaultBumps"
            }
          },
          {
            "name": "totalAmount",
            "docs": [
              "The total liquidity of the vault, including remaining tokens in token_vault and the liquidity in all strategies."
            ],
            "type": "u64"
          },
          {
            "name": "tokenVault",
            "docs": [
              "Token account, hold liquidity in vault reserve"
            ],
            "type": "publicKey"
          },
          {
            "name": "feeVault",
            "docs": [
              "Hold lp token of vault, each time rebalance crank is called, vault calculate performance fee and mint corresponding lp token amount to fee_vault. fee_vault is owned by treasury address"
            ],
            "type": "publicKey"
          },
          {
            "name": "tokenMint",
            "docs": [
              "Token mint that vault supports"
            ],
            "type": "publicKey"
          },
          {
            "name": "lpMint",
            "docs": [
              "Lp mint of vault"
            ],
            "type": "publicKey"
          },
          {
            "name": "strategies",
            "docs": [
              "The list of strategy addresses that vault supports, vault can support up to MAX_STRATEGY strategies at the same time."
            ],
            "type": {
              "array": [
                "publicKey",
                30
              ]
            }
          },
          {
            "name": "base",
            "docs": [
              "The base address to create vault seeds"
            ],
            "type": "publicKey"
          },
          {
            "name": "admin",
            "docs": [
              "Admin of vault"
            ],
            "type": "publicKey"
          },
          {
            "name": "operator",
            "docs": [
              "Person who can send the crank. Operator can only send liquidity to strategies that admin defined, and claim reward to account of treasury address"
            ],
            "type": "publicKey"
          },
          {
            "name": "lockedProfitTracker",
            "docs": [
              "Stores information for locked profit."
            ],
            "type": {
              "defined": "LockedProfitTracker"
            }
          }
        ]
      }
    },
    {
      "name": "strategy",
      "docs": [
        "Strategy struct"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "reserve",
            "docs": [
              "Lending pool address, that the strategy will deposit/withdraw balance"
            ],
            "type": "publicKey"
          },
          {
            "name": "collateralVault",
            "docs": [
              "The token account, that holds the collateral token"
            ],
            "type": "publicKey"
          },
          {
            "name": "strategyType",
            "docs": [
              "Specify type of strategy"
            ],
            "type": {
              "defined": "StrategyType"
            }
          },
          {
            "name": "currentLiquidity",
            "docs": [
              "The liquidity in strategy at the time vault deposit/withdraw from a lending protocol"
            ],
            "type": "u64"
          },
          {
            "name": "bumps",
            "docs": [
              "Hold some bumps, in case the strategy needs to use other seeds to sign a CPI call."
            ],
            "type": {
              "array": [
                "u8",
                10
              ]
            }
          },
          {
            "name": "vault",
            "docs": [
              "Vault address, that the strategy belongs"
            ],
            "type": "publicKey"
          },
          {
            "name": "isDisable",
            "docs": [
              "If we remove strategy by remove_strategy2 endpoint, this account will be never added again"
            ],
            "type": "u8"
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "LockedProfitTracker",
      "docs": [
        "LockedProfitTracker struct"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "lastUpdatedLockedProfit",
            "docs": [
              "The total locked profit from the last report"
            ],
            "type": "u64"
          },
          {
            "name": "lastReport",
            "docs": [
              "The last timestamp (in seconds) rebalancing"
            ],
            "type": "u64"
          },
          {
            "name": "lockedProfitDegradation",
            "docs": [
              "Rate per second of degradation"
            ],
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "VaultBumps",
      "docs": [
        "Vault bumps struct"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "vaultBump",
            "docs": [
              "vault_bump"
            ],
            "type": "u8"
          },
          {
            "name": "tokenVaultBump",
            "docs": [
              "token_vault_bump"
            ],
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "StrategyBumps",
      "docs": [
        "Strategy bumps struct"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "strategyIndex",
            "docs": [
              "strategy_index"
            ],
            "type": "u8"
          },
          {
            "name": "otherBumps",
            "docs": [
              "Bumps of PDAs for the integrated protocol."
            ],
            "type": {
              "array": [
                "u8",
                10
              ]
            }
          }
        ]
      }
    },
    {
      "name": "StrategyType",
      "docs": [
        "StrategyType struct"
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "PortFinanceWithoutLM"
          },
          {
            "name": "PortFinanceWithLM"
          },
          {
            "name": "SolendWithoutLM"
          },
          {
            "name": "Mango"
          },
          {
            "name": "SolendWithLM"
          },
          {
            "name": "ApricotWithoutLM"
          },
          {
            "name": "Francium"
          },
          {
            "name": "Tulip"
          },
          {
            "name": "Vault"
          },
          {
            "name": "Drift"
          },
          {
            "name": "Frakt"
          },
          {
            "name": "Marginfi"
          },
          {
            "name": "Kamino"
          }
        ]
      }
    },
    {
      "name": "VaultType",
      "docs": [
        "Vault type"
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "IdleVault"
          },
          {
            "name": "RebalanceVault"
          }
        ]
      }
    }
  ],
  "events": [
    {
      "name": "AddLiquidity",
      "fields": [
        {
          "name": "lpMintAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "tokenAmount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "RemoveLiquidity",
      "fields": [
        {
          "name": "lpUnmintAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "tokenAmount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "StrategyDeposit",
      "fields": [
        {
          "name": "strategyType",
          "type": {
            "defined": "StrategyType"
          },
          "index": false
        },
        {
          "name": "tokenAmount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "StrategyWithdraw",
      "fields": [
        {
          "name": "strategyType",
          "type": {
            "defined": "StrategyType"
          },
          "index": false
        },
        {
          "name": "collateralAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "estimatedTokenAmount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "ClaimReward",
      "fields": [
        {
          "name": "strategyType",
          "type": {
            "defined": "StrategyType"
          },
          "index": false
        },
        {
          "name": "tokenAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "mintAccount",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "PerformanceFee",
      "fields": [
        {
          "name": "lpMintMore",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "ReportLoss",
      "fields": [
        {
          "name": "strategy",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "loss",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "TotalAmount",
      "fields": [
        {
          "name": "totalAmount",
          "type": "u64",
          "index": false
        }
      ]
    }
  ],
  "errors": [
    {
      "code": 6e3,
      "name": "VaultIsDisabled",
      "msg": "Vault is disabled"
    },
    {
      "code": 6001,
      "name": "ExceededSlippage",
      "msg": "Exceeded slippage tolerance"
    },
    {
      "code": 6002,
      "name": "StrategyIsNotExisted",
      "msg": "Strategy is not existed"
    },
    {
      "code": 6003,
      "name": "UnAuthorized",
      "msg": "UnAuthorized"
    },
    {
      "code": 6004,
      "name": "MathOverflow",
      "msg": "Math operation overflow"
    },
    {
      "code": 6005,
      "name": "ProtocolIsNotSupported",
      "msg": "Protocol is not supported"
    },
    {
      "code": 6006,
      "name": "UnMatchReserve",
      "msg": "Reserve does not support token mint"
    },
    {
      "code": 6007,
      "name": "InvalidLockedProfitDegradation",
      "msg": "lockedProfitDegradation is invalid"
    },
    {
      "code": 6008,
      "name": "MaxStrategyReached",
      "msg": "Maximum number of strategies have been reached"
    },
    {
      "code": 6009,
      "name": "StrategyExisted",
      "msg": "Strategy existed"
    },
    {
      "code": 6010,
      "name": "InvalidUnmintAmount",
      "msg": "Invalid unmint amount"
    },
    {
      "code": 6011,
      "name": "InvalidAccountsForStrategy",
      "msg": "Invalid accounts for strategy"
    },
    {
      "code": 6012,
      "name": "InvalidBump",
      "msg": "Invalid bump"
    },
    {
      "code": 6013,
      "name": "AmountMustGreaterThanZero",
      "msg": "Amount must be greater than 0"
    },
    {
      "code": 6014,
      "name": "MangoIsNotSupportedAnymore",
      "msg": "Mango is not supported anymore"
    },
    {
      "code": 6015,
      "name": "StrategyIsNotSupported",
      "msg": "Strategy is not supported"
    },
    {
      "code": 6016,
      "name": "PayAmountIsExeeced",
      "msg": "Pay amount is exceeded"
    },
    {
      "code": 6017,
      "name": "FeeVaultIsNotSet",
      "msg": "Fee vault is not set"
    },
    {
      "code": 6018,
      "name": "LendingAssertionViolation",
      "msg": "deposit amount in lending is not matched"
    },
    {
      "code": 6019,
      "name": "HaveMoneyInLending",
      "msg": "Cannot remove strategy becase we have some in lending"
    }
  ]
};

// src/stake-for-fee/helpers/program.ts






function createStakeFeeProgram(connection, programId) {
  const provider = new (0, _anchor.AnchorProvider)(
    connection,
    {},
    _anchor.AnchorProvider.defaultOptions()
  );
  return new (0, _anchor.Program)(IDL, programId, provider);
}
function createDynamicAmmProgram(connection, programId) {
  const provider = new (0, _anchor.AnchorProvider)(
    connection,
    {},
    _anchor.AnchorProvider.defaultOptions()
  );
  return new (0, _anchor.Program)(IDL2, programId, provider);
}
function createDynamicVaultProgram(connection, programId) {
  const provider = new (0, _anchor.AnchorProvider)(
    connection,
    {},
    _anchor.AnchorProvider.defaultOptions()
  );
  return new (0, _anchor.Program)(IDL3, programId, provider);
}
async function getOrCreateStakeEscrowInstruction(connection, feeVaultKey, ownerKey, programId) {
  const stakeEscrowKey = deriveStakeEscrow(feeVaultKey, ownerKey, programId);
  const fullBalanceListKey = deriveFullBalanceList(feeVaultKey, programId);
  const topStakerListKey = deriveTopStakerList(feeVaultKey, programId);
  const stakeEscrowAccount = await connection.getAccountInfo(stakeEscrowKey);
  if (!stakeEscrowAccount) {
    const stakeForFeeProgram = createStakeFeeProgram(connection, programId);
    const ix = await stakeForFeeProgram.methods.initializeStakeEscrow().accounts({
      vault: feeVaultKey,
      fullBalanceList: fullBalanceListKey,
      topStakerList: topStakerListKey,
      escrow: stakeEscrowKey,
      owner: ownerKey,
      systemProgram: _web3js.SystemProgram.programId,
      payer: ownerKey
    }).instruction();
    return {
      stakeEscrowKey,
      ix
    };
  } else {
    return {
      stakeEscrowKey,
      ix: null
    };
  }
}
var getOrCreateATAInstruction = async (connection, tokenMint, owner, payer = owner, allowOwnerOffCurve = true) => {
  const toAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
    tokenMint,
    owner,
    allowOwnerOffCurve
  );
  try {
    const account = await connection.getAccountInfo(toAccount);
    if (!account) {
      const ix = _spltoken.createAssociatedTokenAccountInstruction.call(void 0, 
        payer,
        toAccount,
        owner,
        tokenMint
      );
      return { ataPubKey: toAccount, ix };
    }
    return { ataPubKey: toAccount, ix: void 0 };
  } catch (e) {
    if (e instanceof _spltoken.TokenAccountNotFoundError || e instanceof _spltoken.TokenInvalidAccountOwnerError) {
      const ix = _spltoken.createAssociatedTokenAccountInstruction.call(void 0, 
        payer,
        toAccount,
        owner,
        tokenMint
      );
      return { ataPubKey: toAccount, ix };
    } else {
      console.error("Error::getOrCreateATAInstruction", e);
      throw e;
    }
  }
};

// src/stake-for-fee/helpers/staker_for_fee.ts



function findLargestStakerNotInTopListFromFullBalanceList(lookupNumber, fullBalanceListState) {
  const largestStakers = [];
  const fullBalanceListWithoutTopStakers = [...fullBalanceListState.stakers].map((s, idx) => [idx, s]).filter(
    ([_idx, s]) => s.owner != _web3js.PublicKey.default && !Boolean(s.isInTopList)
  );
  if (fullBalanceListWithoutTopStakers.length == 0) {
    return largestStakers;
  }
  const ascSortedFullBalanceList = fullBalanceListWithoutTopStakers.sort(
    ([a_idx, a], [b_idx, b]) => {
      if (a.balance.eq(b.balance)) {
        return b_idx - a_idx;
      } else {
        return a.balance.cmp(b.balance);
      }
    }
  );
  for (let i = 0; i < lookupNumber; i++) {
    const stakerWithIndex = ascSortedFullBalanceList.pop();
    if (stakerWithIndex) {
      const [_idx, staker] = stakerWithIndex;
      largestStakers.push(staker);
    } else {
      break;
    }
  }
  return largestStakers;
}
function findReplaceableTopStaker(lookupNumber, topStakerListState) {
  const smallestStakers = [];
  const actualTopStakers = [...topStakerListState.stakers].filter(
    (s) => !s.fullBalanceIndex.isNeg()
  );
  if (actualTopStakers.length == 0) {
    return smallestStakers;
  }
  const ascSortedTopStakers = actualTopStakers.sort((a, b) => {
    if (a.stakeAmount.eq(b.stakeAmount)) {
      return b.fullBalanceIndex.cmp(a.fullBalanceIndex);
    } else {
      return a.stakeAmount.cmp(b.stakeAmount);
    }
  });
  for (let i = 0; i < lookupNumber; i++) {
    const staker = ascSortedTopStakers.shift();
    if (staker) {
      smallestStakers.push(staker);
    } else {
      break;
    }
  }
  return smallestStakers;
}
function getTopStakerListStateEntryStakeAmount(topStakerListState) {
  let smallestStakeAmount = new (0, _bnjs2.default)("18446744073709551615");
  if (topStakerListState.stakers.length === 0) {
    return new (0, _bnjs2.default)(1);
  }
  for (const staker of topStakerListState.stakers) {
    if (staker.stakeAmount.lt(smallestStakeAmount)) {
      smallestStakeAmount = staker.stakeAmount;
    }
  }
  return smallestStakeAmount.add(new (0, _bnjs2.default)(1));
}
function calculateFeeFarmPerformance(accountStatesT0, accountStatesT1, tokenAUIMultiplier, tokenBUIMultiplier, stakeTokenUIMultiplier, tokenAUsdRate, tokenBUsdRate, stakeTokenUsdRate) {
  const secondsElapsed = new (0, _decimaljs2.default)(
    accountStatesT1.clock.unixTimestamp.sub(accountStatesT0.clock.unixTimestamp).toString()
  );
  let totalFeeAAmountT1 = accountStatesT1.feeVault.metrics.totalFeeAAmount;
  let totalFeeBAmountT1 = accountStatesT1.feeVault.metrics.totalFeeBAmount;
  const totalFeeAAmountClaimableT1 = getLockedEscrowPendingFee(
    accountStatesT1.clock.unixTimestamp,
    accountStatesT1.feeVault,
    accountStatesT1.lockEscrow,
    accountStatesT1.aVault,
    accountStatesT1.bVault,
    accountStatesT1.aVaultLp,
    accountStatesT1.bVaultLp,
    accountStatesT1.aVaultLpMint,
    accountStatesT1.bVaultLpMint,
    accountStatesT1.poolLpMint
  );
  totalFeeAAmountT1 = totalFeeAAmountT1.add(totalFeeAAmountClaimableT1[0]);
  totalFeeBAmountT1 = totalFeeBAmountT1.add(totalFeeAAmountClaimableT1[1]);
  let totalFeeAAmountT0 = accountStatesT0.feeVault.metrics.totalFeeAAmount;
  let totalFeeBAmountT0 = accountStatesT0.feeVault.metrics.totalFeeBAmount;
  const totalFeeAAmountClaimableT0 = getLockedEscrowPendingFee(
    accountStatesT0.clock.unixTimestamp,
    accountStatesT0.feeVault,
    accountStatesT0.lockEscrow,
    accountStatesT0.aVault,
    accountStatesT0.bVault,
    accountStatesT0.aVaultLp,
    accountStatesT0.bVaultLp,
    accountStatesT0.aVaultLpMint,
    accountStatesT0.bVaultLpMint,
    accountStatesT0.poolLpMint
  );
  totalFeeAAmountT0 = totalFeeAAmountT0.add(totalFeeAAmountClaimableT0[0]);
  totalFeeBAmountT0 = totalFeeBAmountT0.add(totalFeeAAmountClaimableT0[1]);
  const feeAAmount = totalFeeAAmountT1.sub(totalFeeAAmountT0);
  const feeBAmount = totalFeeBAmountT1.sub(totalFeeBAmountT0);
  const feeAAmountUi = new (0, _decimaljs2.default)(feeAAmount.toString()).div(
    new (0, _decimaljs2.default)(tokenAUIMultiplier)
  );
  const feeBAmountUi = new (0, _decimaljs2.default)(feeBAmount.toString()).div(
    new (0, _decimaljs2.default)(tokenBUIMultiplier)
  );
  const feeUsd = feeAAmountUi.mul(tokenAUsdRate).add(feeBAmountUi.mul(tokenBUsdRate));
  const usdPerDay = feeUsd.div(secondsElapsed).mul(new (0, _decimaljs2.default)(86400));
  const annualizedFeeUsd = usdPerDay.mul(new (0, _decimaljs2.default)(365));
  const effectiveStakeAmountUi = new (0, _decimaljs2.default)(
    accountStatesT1.feeVault.topStakerInfo.effectiveStakeAmount.toString()
  ).div(stakeTokenUIMultiplier);
  const effectiveUsdAmount = effectiveStakeAmountUi.mul(stakeTokenUsdRate);
  const nominalRate = annualizedFeeUsd.div(effectiveUsdAmount);
  const effectiveRate = new (0, _decimaljs2.default)(1).add(nominalRate.div(new (0, _decimaljs2.default)(365))).pow(new (0, _decimaljs2.default)(365)).sub(new (0, _decimaljs2.default)(1));
  return {
    usdPerDay,
    apr: nominalRate.mul(new (0, _decimaljs2.default)(100)),
    apy: effectiveRate.mul(new (0, _decimaljs2.default)(100))
  };
}
function parseFeeVaultInfo(accountStatesT0, accountStatesT1, tokenAUsdRate, tokenBUsdRate) {
  const {
    feeVault,
    tokenAMint,
    tokenBMint,
    ammPool,
    topStakerListState,
    clock,
    lockEscrow,
    aVault,
    bVault,
    aVaultLp,
    aVaultLpMint,
    bVaultLp,
    bVaultLpMint,
    poolLpMint
  } = accountStatesT1;
  const tokenAUIMultiplier = Math.floor(10 ** tokenAMint.decimals);
  const tokenBUIMultiplier = Math.floor(10 ** tokenBMint.decimals);
  const [stakeTokenUIMultiplier, stakeTokenUsdRate] = ammPool.tokenAMint.equals(
    feeVault.stakeMint
  ) ? [tokenAUIMultiplier, tokenAUsdRate] : [tokenBUIMultiplier, tokenBUsdRate];
  const [claimableFeeAAmount, claimableFeeBAmount] = getLockedEscrowPendingFee(
    clock.unixTimestamp,
    feeVault,
    lockEscrow,
    aVault,
    bVault,
    aVaultLp,
    bVaultLp,
    aVaultLpMint,
    bVaultLpMint,
    poolLpMint
  );
  const totalFeeAAmount = new (0, _decimaljs2.default)(
    feeVault.metrics.totalFeeAAmount.add(claimableFeeAAmount).toString()
  ).div(tokenAUIMultiplier);
  const totalFeeBAmount = new (0, _decimaljs2.default)(
    feeVault.metrics.totalFeeBAmount.add(claimableFeeBAmount).toString()
  ).div(tokenBUIMultiplier);
  const prizeUsd = totalFeeAAmount.mul(tokenAUsdRate).add(totalFeeBAmount.mul(tokenBUsdRate));
  const totalStakedAmount = new (0, _decimaljs2.default)(
    feeVault.metrics.totalStakedAmount.toString()
  ).div(stakeTokenUIMultiplier);
  const totalStakeUsd = totalStakedAmount.mul(stakeTokenUsdRate);
  const performance = calculateFeeFarmPerformance(
    accountStatesT0,
    accountStatesT1,
    tokenAUIMultiplier,
    tokenBUIMultiplier,
    stakeTokenUIMultiplier,
    tokenAUsdRate,
    tokenBUsdRate,
    stakeTokenUsdRate
  );
  const entryStakeAmount = new (0, _decimaljs2.default)(
    getTopStakerListStateEntryStakeAmount(topStakerListState).toString()
  ).div(stakeTokenUIMultiplier);
  const minEntryUsd = entryStakeAmount.mul(stakeTokenUsdRate);
  const secondsElapsedSinceCreated = new (0, _decimaljs2.default)(
    clock.unixTimestamp.sub(feeVault.createdAt).toString()
  );
  const rawContext = {
    totalRewardA: totalFeeAAmount,
    totalRewardB: totalFeeBAmount,
    dailyRewardA: totalFeeAAmount.mul(new (0, _decimaljs2.default)(86400)).div(secondsElapsedSinceCreated),
    dailyRewardB: totalFeeBAmount.mul(new (0, _decimaljs2.default)(86400)).div(secondsElapsedSinceCreated),
    totalStakers: new (0, _decimaljs2.default)(
      feeVault.metrics.totalStakeEscrowCount.toString()
    ),
    totalStakedAmount
  };
  return {
    prizeUsd,
    minEntryUsd,
    totalStakeUsd,
    performance,
    rawContext
  };
}
function parseTopStakerListState(topStakerInfo, topStakerListState, stakeTokenDecimal, feeVaultUsdPerDay) {
  const stakeTokenUiMultiplier = new (0, _decimaljs2.default)(
    Math.floor(10 ** stakeTokenDecimal)
  );
  const effectiveStakeAmount = new (0, _decimaljs2.default)(
    topStakerInfo.effectiveStakeAmount.toString()
  ).div(stakeTokenUiMultiplier);
  const orderedTopStakers = [...topStakerListState.stakers].sort((a, b) => {
    if (a.stakeAmount.eq(b.stakeAmount)) {
      return a.fullBalanceIndex.cmp(b.fullBalanceIndex);
    } else {
      return b.stakeAmount.cmp(a.stakeAmount);
    }
  });
  return orderedTopStakers.map((staker, idx) => {
    const rank = idx + 1;
    const totalStaked = new (0, _decimaljs2.default)(staker.stakeAmount.toString()).div(
      stakeTokenUiMultiplier
    );
    const earning = totalStaked.mul(feeVaultUsdPerDay).div(effectiveStakeAmount);
    return {
      rank,
      wallet: staker.owner,
      totalStaked,
      earning
    };
  });
}
function getStakeEscrowEarningPerDay(stakeEscrow, topStakerInfo, feeVaultUsdPerDay) {
  if (Boolean(stakeEscrow.inTopList)) {
    return new (0, _decimaljs2.default)(stakeEscrow.stakeAmount.toString()).mul(feeVaultUsdPerDay).div(new (0, _decimaljs2.default)(topStakerInfo.effectiveStakeAmount.toString()));
  }
  return new (0, _decimaljs2.default)(0);
}
function getStakeEscrowEarningPerDayAfterUnstake(stakeEscrow, topStakerInfo, unstakeAmount, feeVaultUsdPerDay) {
  const newStakeAmount = stakeEscrow.stakeAmount.sub(unstakeAmount);
  const newEffectiveStakeAmount = topStakerInfo.effectiveStakeAmount.sub(unstakeAmount);
  if (Boolean(stakeEscrow.inTopList)) {
    return new (0, _decimaljs2.default)(newStakeAmount.toString()).mul(feeVaultUsdPerDay).div(new (0, _decimaljs2.default)(newEffectiveStakeAmount.toString()));
  }
  return new (0, _decimaljs2.default)(0);
}

// src/stake-for-fee/helpers/tx.ts






var unwrapSOLInstruction = async (owner) => {
  const wSolATAAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, _spltoken.NATIVE_MINT, owner);
  if (wSolATAAccount) {
    const closedWrappedSolInstruction = _spltoken.createCloseAccountInstruction.call(void 0, 
      wSolATAAccount,
      owner,
      owner
    );
    return closedWrappedSolInstruction;
  }
  return null;
};

// src/stake-for-fee/helpers/compute.ts
var _helpers = require('@solana-developers/helpers');

var getEstimatedComputeUnitUsageWithBuffer = async (connection, instructions, feePayer, buffer) => {
  if (!buffer) {
    buffer = 0.1;
  }
  buffer = Math.max(0, buffer);
  buffer = Math.min(1, buffer);
  const estimatedComputeUnitUsage = await _helpers.getSimulationComputeUnits.call(void 0, 
    connection,
    instructions,
    feePayer,
    []
  );
  const extraComputeUnitBuffer = estimatedComputeUnitUsage * buffer;
  return estimatedComputeUnitUsage + extraComputeUnitBuffer;
};
var getEstimatedComputeUnitIxWithBuffer = async (connection, instructions, feePayer, buffer) => {
  const units = await getEstimatedComputeUnitUsageWithBuffer(
    connection,
    instructions,
    feePayer,
    buffer
  ).catch((error) => {
    console.error("Error::getEstimatedComputeUnitUsageWithBuffer", error);
    return 4e5;
  });
  return _web3js.ComputeBudgetProgram.setComputeUnitLimit({ units });
};

// src/stake-for-fee/index.ts
var StakeForFee2 = class _StakeForFee {
  constructor(connection, stakeForFeeProgram, dynamicAmmProgram, dynamicVaultProgram, feeVaultKey, escrowVaultKey, accountStates) {
    this.connection = connection;
    this.stakeForFeeProgram = stakeForFeeProgram;
    this.dynamicAmmProgram = dynamicAmmProgram;
    this.dynamicVaultProgram = dynamicVaultProgram;
    this.feeVaultKey = feeVaultKey;
    this.escrowVaultKey = escrowVaultKey;
    this.accountStates = accountStates;
  }
  static async create(connection, pool, opt) {
    const stakeForFeeProgram = createStakeFeeProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _ => _.stakeForFeeProgramId]), () => ( STAKE_FOR_FEE_PROGRAM_ID))
    );
    const dynamicVaultProgram = createDynamicVaultProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _2 => _2.dynamicVaultProgramId]), () => ( DYNAMIC_VAULT_PROGRAM_ID))
    );
    const dynamicAmmProgram = createDynamicAmmProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _3 => _3.dynamicAmmProgramId]), () => ( DYNAMIC_AMM_PROGRAM_ID))
    );
    const feeVaultKey = deriveFeeVault(pool, stakeForFeeProgram.programId);
    const fullBalanceListKey = deriveFullBalanceList(
      feeVaultKey,
      stakeForFeeProgram.programId
    );
    const topStakerListKey = deriveTopStakerList(
      feeVaultKey,
      stakeForFeeProgram.programId
    );
    const accountStates = await this.fetchAccountStates(
      connection,
      feeVaultKey,
      topStakerListKey,
      fullBalanceListKey,
      pool,
      opt
    );
    const [lockEscrowPK] = deriveLockEscrowPda(
      pool,
      feeVaultKey,
      dynamicAmmProgram.programId
    );
    const escrowVaultKey = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      accountStates.ammPool.lpMint,
      lockEscrowPK,
      true
    );
    return new _StakeForFee(
      connection,
      stakeForFeeProgram,
      dynamicAmmProgram,
      dynamicVaultProgram,
      feeVaultKey,
      escrowVaultKey,
      accountStates
    );
  }
  /**
   * Fetches all account states required for a given stake-for-fee pool
   *
   * @param connection The connection to the Solana cluster
   * @param feeVaultKey The public key of the fee vault
   * @param topStakerListKey The public key of the top staker list
   * @param fullBalanceListKey The public key of the full balance list
   * @param pool The public key of the pool
   * @param opt An optional object containing the IDs of the programs that
   *            manage the pool. If not provided, the default program IDs
   *            will be used.
   * @returns An object containing all the required account states
   */
  static async fetchAccountStates(connection, feeVaultKey, topStakerListKey, fullBalanceListKey, pool, opt) {
    const stakeForFeeProgram = createStakeFeeProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _4 => _4.stakeForFeeProgramId]), () => ( STAKE_FOR_FEE_PROGRAM_ID))
    );
    const dynamicVaultProgram = createDynamicVaultProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _5 => _5.dynamicVaultProgramId]), () => ( DYNAMIC_VAULT_PROGRAM_ID))
    );
    const dynamicAmmProgram = createDynamicAmmProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _6 => _6.dynamicAmmProgramId]), () => ( DYNAMIC_AMM_PROGRAM_ID))
    );
    const [
      feeVaultAccount,
      fullBalanceListAccount,
      topStakerAccount,
      poolAccount,
      clockAccount
    ] = await connection.getMultipleAccountsInfo([
      feeVaultKey,
      fullBalanceListKey,
      topStakerListKey,
      pool,
      _web3js.SYSVAR_CLOCK_PUBKEY
    ]);
    const feeVaultState = stakeForFeeProgram.coder.accounts.decode(
      "feeVault",
      feeVaultAccount.data
    );
    const fullBalanceListState = decodeFullBalanceState(
      stakeForFeeProgram,
      fullBalanceListAccount
    );
    const topStakerListState = decodeTopStakerListState(
      stakeForFeeProgram,
      feeVaultState,
      topStakerAccount
    );
    const poolState = dynamicAmmProgram.coder.accounts.decode(
      "pool",
      poolAccount.data
    );
    const clockState = ClockLayout.decode(clockAccount.data);
    const [
      aVaultAccount,
      bVaultAccount,
      lockEscrowAccount,
      aVaultLpAccount,
      bVaultLpAccount,
      tokenAMintAccount,
      tokenBMintAccount,
      poolLpMintAccount
    ] = await connection.getMultipleAccountsInfo([
      poolState.aVault,
      poolState.bVault,
      feeVaultState.lockEscrow,
      poolState.aVaultLp,
      poolState.bVaultLp,
      poolState.tokenAMint,
      poolState.tokenBMint,
      poolState.lpMint
    ]);
    const aVaultState = dynamicVaultProgram.coder.accounts.decode(
      "vault",
      aVaultAccount.data
    );
    const bVaultState = dynamicVaultProgram.coder.accounts.decode(
      "vault",
      bVaultAccount.data
    );
    const lockEscrowState = dynamicAmmProgram.coder.accounts.decode(
      "lockEscrow",
      lockEscrowAccount.data
    );
    const aVaultLpState = _spltoken.AccountLayout.decode(
      new Uint8Array(aVaultLpAccount.data)
    );
    const bVaultLpState = _spltoken.AccountLayout.decode(
      new Uint8Array(bVaultLpAccount.data)
    );
    const tokenAMintState = _spltoken.MintLayout.decode(
      new Uint8Array(tokenAMintAccount.data)
    );
    const tokenBMintState = _spltoken.MintLayout.decode(
      new Uint8Array(tokenBMintAccount.data)
    );
    const poolLpMintState = _spltoken.MintLayout.decode(
      new Uint8Array(poolLpMintAccount.data)
    );
    const stakeMintState = feeVaultState.stakeMint.equals(poolState.tokenAMint) ? tokenAMintState : tokenBMintState;
    const escrowVaultKey = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      poolState.lpMint,
      feeVaultKey,
      true
    );
    const [aVaultLpMintAccount, bVaultLpMintAccount] = await connection.getMultipleAccountsInfo([
      aVaultState.lpMint,
      bVaultState.lpMint
    ]);
    const aVaultLpMintState = _spltoken.MintLayout.decode(
      new Uint8Array(aVaultLpMintAccount.data)
    );
    const bVaultLpMintState = _spltoken.MintLayout.decode(
      new Uint8Array(bVaultLpMintAccount.data)
    );
    let accountStates = {
      feeVault: feeVaultState,
      fullBalanceListState,
      topStakerListState,
      ammPool: poolState,
      aVault: aVaultState,
      bVault: bVaultState,
      aVaultLp: aVaultLpState,
      bVaultLp: bVaultLpState,
      lockEscrow: lockEscrowState,
      tokenAMint: tokenAMintState,
      tokenBMint: tokenBMintState,
      stakeMint: stakeMintState,
      aVaultLpMint: aVaultLpMintState,
      bVaultLpMint: bVaultLpMintState,
      clock: clockState,
      poolLpMint: poolLpMintState
    };
    return accountStates;
  }
  /**
   * Creates a fee vault for the given pool.
   *
   * @param connection Solana connection
   * @param pool The pool to create the fee vault for
   * @param stakeMint The mint of the stake token
   * @param lockEscrow The lock escrow account. The owner of the lock escrow must be the fee vault. Integrator must create lock escrow account before calling this instruction.
   * @param payer The payer of the transaction. Signer.
   * @param config The configuration account for the fee vault. Get from `getConfigs`
   * @param customStartClaimFeeTimestamp The custom start claim fee timestamp. If not passed, it will default to current timestamp. Else, lock escrow can only claim fee after this timestamp. Constraint: currentTimestamp <= `customStartClaimFeeTimestamp` <= currentTimestamp + configAccount.joinWindowDuration
   * @param opt Optional options
   *
   * @returns A transaction that can be signed and sent to the network
   */
  static async createFeeVault(connection, pool, stakeMint, payer, param, opt) {
    const stakeForFeeProgram = createStakeFeeProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _7 => _7.stakeForFeeProgramId]), () => ( STAKE_FOR_FEE_PROGRAM_ID))
    );
    const ammProgram = createDynamicAmmProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _8 => _8.dynamicAmmProgramId]), () => ( DYNAMIC_AMM_PROGRAM_ID))
    );
    const poolState = await ammProgram.account.pool.fetch(pool);
    const quoteMint = poolState.tokenAMint.equals(stakeMint) ? poolState.tokenBMint : poolState.tokenAMint;
    const feeVaultKey = deriveFeeVault(pool, stakeForFeeProgram.programId);
    const stakeTokenVaultKey = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      stakeMint,
      feeVaultKey,
      true
    );
    const quoteTokenVaultKey = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      quoteMint,
      feeVaultKey,
      true
    );
    const topStakerListKey = deriveTopStakerList(
      feeVaultKey,
      stakeForFeeProgram.programId
    );
    const fullBalanceListKey = deriveFullBalanceList(
      feeVaultKey,
      stakeForFeeProgram.programId
    );
    const [lockEscrowPK] = deriveLockEscrowPda(
      pool,
      feeVaultKey,
      ammProgram.programId
    );
    const lockEscrowAccount = await connection.getAccountInfo(lockEscrowPK);
    const preInstructions = [];
    if (lockEscrowAccount === null) {
      const createLockEscrowIx = await ammProgram.methods.createLockEscrow().accounts({
        pool,
        lockEscrow: lockEscrowPK,
        owner: feeVaultKey,
        lpMint: poolState.lpMint,
        payer,
        systemProgram: _web3js.SystemProgram.programId
      }).instruction();
      preInstructions.push(createLockEscrowIx);
      const { ix: createEscrowAtaIx } = await getOrCreateATAInstruction(
        connection,
        poolState.lpMint,
        lockEscrowPK,
        payer
      );
      createEscrowAtaIx && preInstructions.push(createEscrowAtaIx);
    }
    const transaction = await stakeForFeeProgram.methods.initializeVault({
      ...param,
      padding: new Array(64).fill(0)
    }).accounts({
      vault: feeVaultKey,
      stakeMint,
      stakeTokenVault: stakeTokenVaultKey,
      quoteMint,
      quoteTokenVault: quoteTokenVaultKey,
      topStakerList: topStakerListKey,
      fullBalanceList: fullBalanceListKey,
      pool,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
      associatedTokenProgram: _spltoken.ASSOCIATED_TOKEN_PROGRAM_ID,
      lockEscrow: lockEscrowPK,
      payer,
      systemProgram: _web3js.SystemProgram.programId
    }).preInstructions(preInstructions).transaction();
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: payer
    }).add(transaction);
  }
  /**
   * Creates a fee vault for the given pool.
   *
   * @param connection Solana connection
   * @param pool The pool to create the fee vault for
   * @param payer The payer of the transaction. Signer.
   * @param config The configuration account for the fee vault. Get from `getConfigs`
   * @param stakeMint The mint of the stake token. Must be token A/B of the pool.
   * @param quoteMint The mint of the quote token. Must be token A/B of the pool.
   * @param customStartClaimFeeTimestamp The custom start claim fee timestamp. If not passed, it will default to current timestamp. Else, lock escrow can only claim fee after this timestamp. Constraint: currentTimestamp <= `customStartClaimFeeTimestamp` <= currentTimestamp + configAccount.joinWindowDuration
   * @param opt Optional options
   *
   * @returns A transaction that can be signed and sent to the network
   */
  static async createFeeVaultWithParams(connection, pool, payer, stakeMint, quoteMint, param, opt) {
    const stakeForFeeProgram = createStakeFeeProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _9 => _9.stakeForFeeProgramId]), () => ( STAKE_FOR_FEE_PROGRAM_ID))
    );
    const ammProgram = createDynamicAmmProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _10 => _10.dynamicAmmProgramId]), () => ( DYNAMIC_AMM_PROGRAM_ID))
    );
    const feeVaultKey = deriveFeeVault(pool, stakeForFeeProgram.programId);
    const lpMint = deriveLpMint(pool, ammProgram.programId);
    const topStakerListKey = deriveTopStakerList(
      feeVaultKey,
      stakeForFeeProgram.programId
    );
    const fullBalanceListKey = deriveFullBalanceList(
      feeVaultKey,
      stakeForFeeProgram.programId
    );
    const stakeTokenVaultKey = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      stakeMint,
      feeVaultKey,
      true
    );
    const quoteTokenVaultKey = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      quoteMint,
      feeVaultKey,
      true
    );
    const [lockEscrowPK] = deriveLockEscrowPda(
      pool,
      feeVaultKey,
      ammProgram.programId
    );
    const lockEscrowAccount = await connection.getAccountInfo(lockEscrowPK);
    const preInstructions = [];
    if (lockEscrowAccount === null) {
      const createLockEscrowIx = await ammProgram.methods.createLockEscrow().accounts({
        pool,
        lockEscrow: lockEscrowPK,
        owner: feeVaultKey,
        lpMint,
        payer,
        systemProgram: _web3js.SystemProgram.programId
      }).instruction();
      preInstructions.push(createLockEscrowIx);
    }
    const transaction = await stakeForFeeProgram.methods.initializeVault({
      ...param,
      padding: new Array(64).fill(0)
    }).accounts({
      vault: feeVaultKey,
      stakeTokenVault: stakeTokenVaultKey,
      quoteTokenVault: quoteTokenVaultKey,
      stakeMint,
      quoteMint,
      topStakerList: topStakerListKey,
      fullBalanceList: fullBalanceListKey,
      pool,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
      associatedTokenProgram: _spltoken.ASSOCIATED_TOKEN_PROGRAM_ID,
      lockEscrow: lockEscrowPK,
      payer,
      systemProgram: _web3js.SystemProgram.programId
    }).preInstructions(preInstructions).transaction();
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: payer
    }).add(transaction);
  }
  /**
   * Creates a fee vault for the given pool.
   *
   * @param connection Solana connection
   * @param pool The pool to create the fee vault for
   * @param payer The payer of the transaction. Signer.
   * @param config The configuration account for the fee vault. Get from `getConfigs`
   * @param stakeMint The mint of the stake token. Must be token A/B of the pool.
   * @param quoteMint The mint of the quote token. Must be token A/B of the pool.
   * @param customStartClaimFeeTimestamp The custom start claim fee timestamp. If not passed, it will default to current timestamp. Else, lock escrow can only claim fee after this timestamp. Constraint: currentTimestamp <= `customStartClaimFeeTimestamp` <= currentTimestamp + configAccount.joinWindowDuration
   * @param opt Optional options
   *
   * @returns An instruction
   */
  static async createFeeVaultInstructions(connection, pool, payer, stakeMint, quoteMint, param, opt) {
    const stakeForFeeProgram = createStakeFeeProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _11 => _11.stakeForFeeProgramId]), () => ( STAKE_FOR_FEE_PROGRAM_ID))
    );
    const ammProgram = createDynamicAmmProgram(
      connection,
      _nullishCoalesce(_optionalChain([opt, 'optionalAccess', _12 => _12.dynamicAmmProgramId]), () => ( DYNAMIC_AMM_PROGRAM_ID))
    );
    const feeVaultKey = deriveFeeVault(pool, stakeForFeeProgram.programId);
    const lpMint = deriveLpMint(pool, ammProgram.programId);
    const topStakerListKey = deriveTopStakerList(
      feeVaultKey,
      stakeForFeeProgram.programId
    );
    const fullBalanceListKey = deriveFullBalanceList(
      feeVaultKey,
      stakeForFeeProgram.programId
    );
    const stakeTokenVaultKey = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      stakeMint,
      feeVaultKey,
      true
    );
    const quoteTokenVaultKey = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      quoteMint,
      feeVaultKey,
      true
    );
    const [lockEscrowPK] = deriveLockEscrowPda(
      pool,
      feeVaultKey,
      ammProgram.programId
    );
    const lockEscrowAccount = await connection.getAccountInfo(lockEscrowPK);
    const instructions = [];
    if (lockEscrowAccount === null) {
      const createLockEscrowIx = await ammProgram.methods.createLockEscrow().accounts({
        pool,
        lockEscrow: lockEscrowPK,
        owner: feeVaultKey,
        lpMint,
        payer,
        systemProgram: _web3js.SystemProgram.programId
      }).instruction();
      instructions.push(createLockEscrowIx);
    }
    const createFeeVaultIx = await stakeForFeeProgram.methods.initializeVault({
      ...param,
      padding: new Array(64).fill(0)
    }).accounts({
      vault: feeVaultKey,
      stakeTokenVault: stakeTokenVaultKey,
      quoteTokenVault: quoteTokenVaultKey,
      stakeMint,
      quoteMint,
      topStakerList: topStakerListKey,
      fullBalanceList: fullBalanceListKey,
      pool,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
      associatedTokenProgram: _spltoken.ASSOCIATED_TOKEN_PROGRAM_ID,
      lockEscrow: lockEscrowPK,
      payer,
      systemProgram: _web3js.SystemProgram.programId
    }).instruction();
    instructions.push(createFeeVaultIx);
    return instructions;
  }
  /**
   * Initializes a stake escrow for the given owner.
   *
   * @param connection Solana connection
   * @param owner The owner of the stake escrow. Signer.
   *
   * @returns A transaction that can be signed and sent to the network
   */
  async initializeStakeEscrow(owner) {
    const stakeEscrowKey = deriveStakeEscrow(
      this.feeVaultKey,
      owner,
      this.stakeForFeeProgram.programId
    );
    const transaction = await this.stakeForFeeProgram.methods.initializeStakeEscrow().accounts({
      vault: this.feeVaultKey,
      fullBalanceList: this.accountStates.feeVault.fullBalanceList,
      topStakerList: this.accountStates.feeVault.topStakerList,
      escrow: stakeEscrowKey,
      owner,
      systemProgram: _web3js.SystemProgram.programId
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash();
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(transaction);
  }
  findSmallestStakeEscrowInFullBalanceList(skipOwner) {
    if (this.accountStates.fullBalanceListState.stakers.length == 0) {
      return null;
    }
    const endIdx = this.accountStates.fullBalanceListState.stakers.length - 1;
    let smallestBalance = U64_MAX;
    let smallestOwner = null;
    for (let i = endIdx; i >= 0; i--) {
      const staker = this.accountStates.fullBalanceListState.stakers[i];
      if (staker.owner.equals(skipOwner)) {
        continue;
      }
      if (staker.balance.isZero()) {
        smallestOwner = staker.owner;
        break;
      }
      if (staker.balance.lt(smallestBalance)) {
        smallestOwner = staker.owner;
        smallestBalance = staker.balance;
      }
    }
    return smallestOwner ? deriveStakeEscrow(
      this.feeVaultKey,
      smallestOwner,
      this.stakeForFeeProgram.programId
    ) : null;
  }
  findLargestStakerNotInTopListFromFullBalanceList(lookupNumber) {
    return findLargestStakerNotInTopListFromFullBalanceList(
      lookupNumber,
      this.accountStates.fullBalanceListState
    ).map((s) => {
      return deriveStakeEscrow(
        this.feeVaultKey,
        s.owner,
        this.stakeForFeeProgram.programId
      );
    });
  }
  findReplaceableTopStaker(lookupNumber) {
    return findReplaceableTopStaker(
      lookupNumber,
      this.accountStates.topStakerListState
    ).map((s) => {
      return deriveStakeEscrow(
        this.feeVaultKey,
        s.owner,
        this.stakeForFeeProgram.programId
      );
    });
  }
  /**
   * Withdraws the tokens from the given unstake key and sends them to the given owner.
   * @param unstakeKey The public key of the unstake account to withdraw from.
   * @param owner The public key of the account to send the withdrawn tokens to.
   * @returns A transaction that can be signed and sent to the network.
   */
  async withdraw(unstakeKey, owner) {
    const stakeEscrowKey = deriveStakeEscrow(
      this.feeVaultKey,
      owner,
      this.stakeForFeeProgram.programId
    );
    const preInstructions = [];
    const { ataPubKey: userStakeToken, ix: initializeUserStakeTokenIx } = await getOrCreateATAInstruction(
      this.connection,
      this.accountStates.feeVault.stakeMint,
      owner
    );
    initializeUserStakeTokenIx && preInstructions.push(initializeUserStakeTokenIx);
    const transaction = await this.stakeForFeeProgram.methods.withdraw().accounts({
      unstake: unstakeKey,
      stakeEscrow: stakeEscrowKey,
      stakeTokenVault: this.accountStates.feeVault.stakeTokenVault,
      vault: this.feeVaultKey,
      userStakeToken,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
      owner
    }).preInstructions(preInstructions).transaction();
    const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash();
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(transaction);
  }
  /**
   * Requests to unstake a given amount of tokens from the vault.
   * Creates a new `Unstake` account and initializes it to the given owner.
   *
   * @param amount The amount of tokens to unstake
   * @param unstakeKeypair The new unstake account. Arbitrarily generated. Signer.
   * @param owner The owner of the stake. Signer.
   * @returns The transaction to execute the unstake instruction
   */
  async unstake(amount, unstakeKeypair, owner) {
    const stakeEscrowKey = deriveStakeEscrow(
      this.feeVaultKey,
      owner,
      this.stakeForFeeProgram.programId
    );
    const stakeEscrowState = await this.stakeForFeeProgram.account.stakeEscrow.fetch(stakeEscrowKey);
    const remainingAccounts = [];
    if (Boolean(stakeEscrowState.inTopList)) {
      const candidateToEnterTopList = this.findLargestStakerNotInTopListFromFullBalanceList(3).map((key) => {
        return {
          pubkey: key,
          isSigner: false,
          isWritable: true
        };
      });
      remainingAccounts.push(...candidateToEnterTopList);
    }
    const transaction = await this.stakeForFeeProgram.methods.requestUnstake(amount).accounts({
      unstake: unstakeKeypair,
      vault: this.feeVaultKey,
      topStakerList: this.accountStates.feeVault.topStakerList,
      fullBalanceList: this.accountStates.feeVault.fullBalanceList,
      stakeEscrow: stakeEscrowKey,
      stakeTokenVault: this.accountStates.feeVault.stakeTokenVault,
      quoteTokenVault: this.accountStates.feeVault.quoteTokenVault,
      owner,
      pool: this.accountStates.feeVault.pool,
      lpMint: this.accountStates.ammPool.lpMint,
      lockEscrow: this.accountStates.feeVault.lockEscrow,
      escrowVault: this.escrowVaultKey,
      aTokenVault: this.accountStates.aVault.tokenVault,
      bTokenVault: this.accountStates.bVault.tokenVault,
      aVault: this.accountStates.ammPool.aVault,
      bVault: this.accountStates.ammPool.bVault,
      aVaultLp: this.accountStates.ammPool.aVaultLp,
      bVaultLp: this.accountStates.ammPool.bVaultLp,
      aVaultLpMint: this.accountStates.aVault.lpMint,
      bVaultLpMint: this.accountStates.bVault.lpMint,
      ammProgram: this.dynamicAmmProgram.programId,
      vaultProgram: this.dynamicVaultProgram.programId,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID
    }).remainingAccounts(remainingAccounts).transaction();
    const [{ blockhash, lastValidBlockHeight }, setCUIx] = await Promise.all([
      this.connection.getLatestBlockhash(),
      getEstimatedComputeUnitIxWithBuffer(
        this.stakeForFeeProgram.provider.connection,
        transaction.instructions,
        owner
      )
    ]);
    transaction.instructions.unshift(setCUIx);
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(transaction);
  }
  /**
   * @description
   * Claim fee from stake escrow.
   *
   * @param owner Owner of stake escrow.
   * @param maxFee Max fee
   * @returns Transaction
   */
  async claimFee(owner, maxFee) {
    const stakeEscrowKey = deriveStakeEscrow(
      this.feeVaultKey,
      owner,
      this.stakeForFeeProgram.programId
    );
    const quoteTokenMint = this.accountStates.ammPool.tokenAMint.equals(
      this.accountStates.feeVault.stakeMint
    ) ? this.accountStates.ammPool.tokenBMint : this.accountStates.ammPool.tokenAMint;
    const preInstructions = [];
    const { ataPubKey: userQuoteToken, ix: initializeUserQuoteTokenIx } = await getOrCreateATAInstruction(this.connection, quoteTokenMint, owner);
    initializeUserQuoteTokenIx && preInstructions.push(initializeUserQuoteTokenIx);
    const remainingAccounts = [];
    const smallestStakeEscrows = this.findReplaceableTopStaker(2).map((key) => {
      return {
        pubkey: key,
        isWritable: true,
        isSigner: false
      };
    });
    remainingAccounts.push(...smallestStakeEscrows);
    const smallestStakeEscrow = this.findSmallestStakeEscrowInFullBalanceList(owner);
    const postInstructions = [await unwrapSOLInstruction(owner)];
    const transaction = await this.stakeForFeeProgram.methods.claimFee(maxFee).accounts({
      userQuoteToken,
      vault: this.feeVaultKey,
      fullBalanceList: this.accountStates.feeVault.fullBalanceList,
      topStakerList: this.accountStates.feeVault.topStakerList,
      stakeEscrow: stakeEscrowKey,
      stakeTokenVault: this.accountStates.feeVault.stakeTokenVault,
      quoteTokenVault: this.accountStates.feeVault.quoteTokenVault,
      owner,
      pool: this.accountStates.feeVault.pool,
      lpMint: this.accountStates.ammPool.lpMint,
      lockEscrow: this.accountStates.feeVault.lockEscrow,
      escrowVault: this.escrowVaultKey,
      aTokenVault: this.accountStates.aVault.tokenVault,
      bTokenVault: this.accountStates.bVault.tokenVault,
      aVault: this.accountStates.ammPool.aVault,
      bVault: this.accountStates.ammPool.bVault,
      aVaultLp: this.accountStates.ammPool.aVaultLp,
      bVaultLp: this.accountStates.ammPool.bVaultLp,
      aVaultLpMint: this.accountStates.aVault.lpMint,
      bVaultLpMint: this.accountStates.bVault.lpMint,
      ammProgram: this.dynamicAmmProgram.programId,
      vaultProgram: this.dynamicVaultProgram.programId,
      smallestStakeEscrow,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID
    }).preInstructions(preInstructions).postInstructions(postInstructions).remainingAccounts(remainingAccounts).transaction();
    const [{ blockhash, lastValidBlockHeight }, setCUIx] = await Promise.all([
      this.connection.getLatestBlockhash(),
      getEstimatedComputeUnitIxWithBuffer(
        this.stakeForFeeProgram.provider.connection,
        transaction.instructions,
        owner
      )
    ]);
    transaction.instructions.unshift(setCUIx);
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(transaction);
  }
  /**
   * Stake tokens in the vault for the given owner.
   *
   * Creates a new stake escrow if one doesn't exist.
   *
   * @param maxAmount The max amount of tokens to stake
   * @param owner The owner of the stake. Signer.
   * @param owner The payer for fee and account rental. Signer.
   * @param replaceableTopStakerCount The number of top stakers that can be replaced. Default is 2 (Max = 2).
   * @returns The transaction to execute the stake instruction
   */
  async stake(maxAmount, owner, replaceableTopStakerCount = 2) {
    if (replaceableTopStakerCount > 2) {
      throw new Error(
        "replaceableTopStakerCount must be less than or equal to 2"
      );
    }
    const preInstructions = [];
    const { stakeEscrowKey, ix: initializeStakeEscrowIx } = await getOrCreateStakeEscrowInstruction(
      this.connection,
      this.feeVaultKey,
      owner,
      this.stakeForFeeProgram.programId
    );
    initializeStakeEscrowIx && preInstructions.push(initializeStakeEscrowIx);
    const userStakeTokenKey = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      this.accountStates.feeVault.stakeMint,
      owner
    );
    const remainingAccounts = [];
    const smallestStakeEscrows = this.findReplaceableTopStaker(replaceableTopStakerCount).map((key) => {
      return {
        pubkey: key,
        isWritable: true,
        isSigner: false
      };
    });
    remainingAccounts.push(...smallestStakeEscrows);
    const smallestStakeEscrow = this.findSmallestStakeEscrowInFullBalanceList(owner);
    const transaction = await this.stakeForFeeProgram.methods.stake(maxAmount).accounts({
      vault: this.feeVaultKey,
      stakeTokenVault: this.accountStates.feeVault.stakeTokenVault,
      quoteTokenVault: this.accountStates.feeVault.quoteTokenVault,
      topStakerList: this.accountStates.feeVault.topStakerList,
      fullBalanceList: this.accountStates.feeVault.fullBalanceList,
      stakeEscrow: stakeEscrowKey,
      smallestStakeEscrow,
      userStakeToken: userStakeTokenKey,
      owner,
      pool: this.accountStates.feeVault.pool,
      lpMint: this.accountStates.ammPool.lpMint,
      lockEscrow: this.accountStates.feeVault.lockEscrow,
      escrowVault: this.escrowVaultKey,
      aTokenVault: this.accountStates.aVault.tokenVault,
      bTokenVault: this.accountStates.bVault.tokenVault,
      aVault: this.accountStates.ammPool.aVault,
      bVault: this.accountStates.ammPool.bVault,
      aVaultLp: this.accountStates.ammPool.aVaultLp,
      bVaultLp: this.accountStates.ammPool.bVaultLp,
      aVaultLpMint: this.accountStates.aVault.lpMint,
      bVaultLpMint: this.accountStates.bVault.lpMint,
      ammProgram: this.dynamicAmmProgram.programId,
      vaultProgram: this.dynamicVaultProgram.programId,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID
    }).preInstructions(preInstructions).remainingAccounts(remainingAccounts).transaction();
    const [{ blockhash, lastValidBlockHeight }, setCUIx] = await Promise.all([
      this.connection.getLatestBlockhash(),
      getEstimatedComputeUnitIxWithBuffer(
        this.stakeForFeeProgram.provider.connection,
        transaction.instructions,
        owner
      )
    ]);
    transaction.instructions.unshift(setCUIx);
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(transaction);
  }
  /**
   * Cancels an unstake request, given the public key of the unstake account.
   * @param unstakeKey The public key of the unstake account to cancel.
   * @param owner The public key of the owner of the stake.
   * @returns A transaction to execute the cancel unstake instruction.
   */
  async cancelUnstake(unstakeKey, owner) {
    const stakeEscrowKey = deriveStakeEscrow(
      this.feeVaultKey,
      owner,
      this.stakeForFeeProgram.programId
    );
    const remainingAccounts = [];
    const stakeEscrowState = await this.stakeForFeeProgram.account.stakeEscrow.fetch(stakeEscrowKey);
    if (!Boolean(stakeEscrowState.inTopList)) {
      const smallestStakeEscrows = this.findReplaceableTopStaker(3).map((key) => {
        return {
          pubkey: key,
          isWritable: true,
          isSigner: false
        };
      });
      remainingAccounts.push(...smallestStakeEscrows);
    }
    const smallestStakeEscrow = this.findSmallestStakeEscrowInFullBalanceList(owner);
    const preInstructions = [];
    const transaction = await this.stakeForFeeProgram.methods.cancelUnstake().accounts({
      unstake: unstakeKey,
      vault: this.feeVaultKey,
      topStakerList: this.accountStates.feeVault.topStakerList,
      fullBalanceList: this.accountStates.feeVault.fullBalanceList,
      stakeEscrow: stakeEscrowKey,
      smallestStakeEscrow,
      stakeTokenVault: this.accountStates.feeVault.stakeTokenVault,
      quoteTokenVault: this.accountStates.feeVault.quoteTokenVault,
      owner,
      pool: this.accountStates.feeVault.pool,
      lpMint: this.accountStates.ammPool.lpMint,
      lockEscrow: this.accountStates.feeVault.lockEscrow,
      escrowVault: this.escrowVaultKey,
      aTokenVault: this.accountStates.aVault.tokenVault,
      bTokenVault: this.accountStates.bVault.tokenVault,
      aVault: this.accountStates.ammPool.aVault,
      bVault: this.accountStates.ammPool.bVault,
      aVaultLp: this.accountStates.ammPool.aVaultLp,
      bVaultLp: this.accountStates.ammPool.bVaultLp,
      aVaultLpMint: this.accountStates.aVault.lpMint,
      bVaultLpMint: this.accountStates.bVault.lpMint,
      ammProgram: this.dynamicAmmProgram.programId,
      vaultProgram: this.dynamicVaultProgram.programId,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID
    }).remainingAccounts(remainingAccounts).preInstructions(preInstructions).transaction();
    const [{ blockhash, lastValidBlockHeight }, setCUIx] = await Promise.all([
      this.connection.getLatestBlockhash(),
      getEstimatedComputeUnitIxWithBuffer(
        this.stakeForFeeProgram.provider.connection,
        transaction.instructions,
        owner
      )
    ]);
    transaction.instructions.unshift(setCUIx);
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(transaction);
  }
  /**
   * Refreshes the account states and returns the old states.
   *
   * @returns Old AccountStates object
   */
  async refreshStates() {
    const oldAccountStates = this.accountStates;
    this.accountStates = await _StakeForFee.fetchAccountStates(
      this.connection,
      this.feeVaultKey,
      this.accountStates.feeVault.topStakerList,
      this.accountStates.feeVault.fullBalanceList,
      this.accountStates.feeVault.pool,
      {
        stakeForFeeProgramId: this.stakeForFeeProgram.programId,
        dynamicAmmProgramId: this.dynamicAmmProgram.programId,
        dynamicVaultProgramId: this.dynamicVaultProgram.programId
      }
    );
    return oldAccountStates;
  }
  /** Start of helper functions */
  /**
   * Gets all staked info for the given owner.
   *
   * @param connection The connection to use.
   * @param owner The owner's pubkey.
   * @returns A promise that resolves with an array of stake escrows that match the given owner.
   */
  static async getAllStakedVaultByUser(connection, owner) {
    const stakeForFeeProgram = createStakeFeeProgram(
      connection,
      STAKE_FOR_FEE_PROGRAM_ID
    );
    const [stakeEscrow, unstakeList] = await Promise.all([
      stakeForFeeProgram.account.stakeEscrow.all([
        { memcmp: { offset: 8, bytes: owner.toBase58() } }
      ]),
      stakeForFeeProgram.account.unstake.all([
        { memcmp: { offset: 8 + 32 + 8 * 3, bytes: owner.toBase58() } }
      ])
    ]);
    const vaultsKey = stakeEscrow.map((stake) => stake.account.vault);
    const vaults = await stakeForFeeProgram.account.feeVault.fetchMultiple(
      vaultsKey
    );
    return stakeEscrow.map((stake, index) => {
      const vault = vaults[index];
      const unstake = unstakeList.filter(({ account }) => account.stakeEscrow.equals(stake.publicKey)).map(({ account }) => account);
      return { stake: stake.account, vault, unstake };
    });
  }
  /**
   * Gets all unstake records for the given stake escrow.
   *
   * @param connection The connection to use.
   * @param owner The owner's pubkey.
   * @returns A promise that resolves with an array of unstake records that match the given stake escrow.
   */
  static async getUnstakeByUser(connection, owner, feeVault) {
    const stakeForFeeProgram = createStakeFeeProgram(
      connection,
      STAKE_FOR_FEE_PROGRAM_ID
    );
    const [{ publicKey: stakeEscrow }] = await stakeForFeeProgram.account.stakeEscrow.all([
      { memcmp: { offset: 8, bytes: owner.toBase58() } },
      { memcmp: { offset: 8 + 32, bytes: feeVault.toBase58() } }
    ]);
    return await stakeForFeeProgram.account.unstake.all([
      {
        memcmp: {
          offset: 8,
          bytes: stakeEscrow.toBase58()
        }
      }
    ]);
  }
  /**
   * Gets all fee vault accounts for the given stake-for-fee program.
   * @param connection The connection to use.
   * @param programId The program id of the stake-for-fee program. Defaults to the idl program id.
   * @returns A promise that resolves with an array of fee vault accounts.
   */
  static async getAllFeeVault(connection, programId) {
    const stakeForFeeProgram = createStakeFeeProgram(
      connection,
      _nullishCoalesce(programId, () => ( STAKE_FOR_FEE_PROGRAM_ID))
    );
    return stakeForFeeProgram.account.feeVault.all();
  }
  /**
   * Calculates the minimum stake amount required to enter the top staker list.
   * @returns The minimum stake amount required to enter the top staker list.
   */
  getTopStakerListEntryStakeAmount() {
    return getTopStakerListStateEntryStakeAmount(
      this.accountStates.topStakerListState
    );
  }
  /**
   * Calculates the total amount of fees that are pending to be claimed from the locked escrow for the farm.
   * @returns The total amount of fees that are pending to be claimed from the locked escrow for the farm.
   */
  getFarmPendingClaimFees() {
    return getLockedEscrowPendingFee(
      this.accountStates.clock.unixTimestamp,
      this.accountStates.feeVault,
      this.accountStates.lockEscrow,
      this.accountStates.aVault,
      this.accountStates.bVault,
      this.accountStates.aVaultLp,
      this.accountStates.bVaultLp,
      this.accountStates.aVaultLpMint,
      this.accountStates.bVaultLpMint,
      this.accountStates.poolLpMint
    );
  }
  /**
   * Calculates the total amount of fees that have been released from the locked escrow to the top staker list for the farm.
   * @returns An array of two BNs. The first element is the total amount of token A fees that have been released. The second element is the total amount of token B fees that have been released.
   */
  getFarmReleasedFees() {
    const [newFeeA, newFeeB] = this.getFarmPendingClaimFees();
    const newLockedFeeA = this.accountStates.feeVault.topStakerInfo.lockedFeeA.add(newFeeA);
    const newLockedFeeB = this.accountStates.feeVault.topStakerInfo.lockedFeeB.add(newFeeB);
    const currentTime = this.accountStates.clock.unixTimestamp;
    const secondsElapsed = currentTime.sub(
      this.accountStates.feeVault.topStakerInfo.lastUpdatedAt
    );
    const secondsToFullUnlock = this.accountStates.feeVault.configuration.secondsToFullUnlock;
    if (secondsElapsed.gte(secondsToFullUnlock)) {
      return [newLockedFeeA, newLockedFeeB];
    }
    const releasedFeeA = newLockedFeeA.mul(secondsElapsed).div(secondsToFullUnlock);
    const releasedFeeB = newLockedFeeB.mul(secondsElapsed).div(secondsToFullUnlock);
    return [releasedFeeA, releasedFeeB];
  }
  /**
   * The function `getUserStakeAndClaimBalance` calculates the stake amount and unclaimed fees for a
   * user in a staking program.
   * @param {PublicKey} user - The `getUserStakeAndClaimBalance` function calculates the stake amount
   * and unclaimed fees for a specific user. Here's a breakdown of the parameters used in the function:
   * @returns The function `getUserStakeAndClaimBalance` returns an object with two properties:
   * 1. `stakedAmount`: The amount of stake in the stake escrow account for the specified user.
   * 2. `unclaimFe`: An object containing two properties:
   *    - `feeA`: The total amount of fee A that can be claimed by the user, which includes both the
   * new fee A calculated
   *    - `feeB`: The total amount of fee B that can be claimed by the user, which includes both the
   * new fee B calculated
   */
  async getUserStakeAndClaimBalance(user) {
    const stakeEscrowKey = deriveStakeEscrow(
      this.feeVaultKey,
      user,
      this.stakeForFeeProgram.programId
    );
    const stakeEscrow = await this.stakeForFeeProgram.account.stakeEscrow.fetchNullable(
      stakeEscrowKey
    );
    if (!stakeEscrow) {
      return {
        stakeEscrow: null,
        unclaimFee: {
          feeA: null,
          feeB: null
        }
      };
    }
    if (!Boolean(stakeEscrow.inTopList)) {
      return {
        stakeEscrow,
        unclaimFee: {
          feeA: stakeEscrow.feeAPending,
          feeB: stakeEscrow.feeBPending
        }
      };
    }
    const [releasedFeeA, releasedFeeB] = this.getFarmReleasedFees();
    const effectiveStakeAmount = this.accountStates.feeVault.topStakerInfo.effectiveStakeAmount;
    const newFeeAPerLiquidity = releasedFeeA.isNeg() || effectiveStakeAmount.isZero() ? new (0, _anchor.BN)(0) : releasedFeeA.shln(64).div(effectiveStakeAmount);
    const newFeeBPerLiquidity = releasedFeeB.isNeg() || effectiveStakeAmount.isZero() ? new (0, _anchor.BN)(0) : releasedFeeB.shln(64).div(effectiveStakeAmount);
    const newCumulativeFeeAPerLiquidity = this.accountStates.feeVault.topStakerInfo.cumulativeFeeAPerLiquidity.add(
      newFeeAPerLiquidity
    );
    const newCumulativeFeeBPerLiquidity = this.accountStates.feeVault.topStakerInfo.cumulativeFeeBPerLiquidity.add(
      newFeeBPerLiquidity
    );
    const newFeeA = newCumulativeFeeAPerLiquidity.sub(stakeEscrow.feeAPerLiquidityCheckpoint).mul(stakeEscrow.stakeAmount).shrn(64);
    const newFeeB = newCumulativeFeeBPerLiquidity.sub(stakeEscrow.feeBPerLiquidityCheckpoint).mul(stakeEscrow.stakeAmount).shrn(64);
    return {
      stakeEscrow,
      unclaimFee: {
        feeA: newFeeA.add(stakeEscrow.feeAPending),
        feeB: newFeeB.add(stakeEscrow.feeBPending)
      }
    };
  }
  /**
   * Calculates the total amount of fees that are pending to be claimed for the given stake escrow.
   * @param stakeEscrow The stake escrow to calculate the pending fees for.
   * @returns An array of two BNs. The first element is the total amount of token A fees that are pending to be claimed. The second element is the total amount of token B fees that are pending to be claimed.
   */
  getStakeEscrowPendingFees(stakeEscrow) {
    const [releasedFeeA, releasedFeeB] = this.getFarmReleasedFees();
    const effectiveStakeAmount = this.accountStates.feeVault.topStakerInfo.effectiveStakeAmount;
    const newFeeAPerLiquidity = releasedFeeA.shln(64).div(effectiveStakeAmount);
    const newFeeBPerLiquidity = releasedFeeB.shln(64).div(effectiveStakeAmount);
    const newCumulativeFeeAPerLiquidity = this.accountStates.feeVault.topStakerInfo.cumulativeFeeAPerLiquidity.add(
      newFeeAPerLiquidity
    );
    const newCumulativeFeeBPerLiquidity = this.accountStates.feeVault.topStakerInfo.cumulativeFeeBPerLiquidity.add(
      newFeeBPerLiquidity
    );
    const newFeeA = newCumulativeFeeAPerLiquidity.sub(stakeEscrow.feeAPerLiquidityCheckpoint).mul(stakeEscrow.stakeAmount).shrn(64);
    const newFeeB = newCumulativeFeeBPerLiquidity.sub(stakeEscrow.feeBPerLiquidityCheckpoint).mul(stakeEscrow.stakeAmount).shrn(64);
    return [
      newFeeA.add(stakeEscrow.feeAPending),
      newFeeB.add(stakeEscrow.feeBPending)
    ];
  }
};

// src/index.ts
var src_default = StakeForFee2;


































exports.ClockLayout = ClockLayout; exports.DYNAMIC_AMM_PROGRAM_ID = DYNAMIC_AMM_PROGRAM_ID; exports.DYNAMIC_VAULT_PROGRAM_ID = DYNAMIC_VAULT_PROGRAM_ID; exports.FULL_BALANCE_LIST_HARD_LIMIT = FULL_BALANCE_LIST_HARD_LIMIT; exports.IDL = IDL; exports.MIN_LOCK_ESCROW_CLAIM_FEE_DURATION = MIN_LOCK_ESCROW_CLAIM_FEE_DURATION; exports.STAKE_FOR_FEE_PROGRAM_ID = STAKE_FOR_FEE_PROGRAM_ID; exports.U64_MAX = U64_MAX; exports.calculateFeeFarmPerformance = calculateFeeFarmPerformance; exports.createDynamicAmmProgram = createDynamicAmmProgram; exports.createDynamicVaultProgram = createDynamicVaultProgram; exports.createStakeFeeProgram = createStakeFeeProgram; exports.decodeFullBalanceState = decodeFullBalanceState; exports.decodeTopStakerListState = decodeTopStakerListState; exports.default = src_default; exports.deriveFeeVault = deriveFeeVault; exports.deriveFullBalanceList = deriveFullBalanceList; exports.deriveLockEscrowPda = deriveLockEscrowPda; exports.deriveLpMint = deriveLpMint; exports.deriveStakeEscrow = deriveStakeEscrow; exports.deriveTopStakerList = deriveTopStakerList; exports.findLargestStakerNotInTopListFromFullBalanceList = findLargestStakerNotInTopListFromFullBalanceList; exports.findReplaceableTopStaker = findReplaceableTopStaker; exports.getLockedEscrowPendingFee = getLockedEscrowPendingFee; exports.getOrCreateATAInstruction = getOrCreateATAInstruction; exports.getOrCreateStakeEscrowInstruction = getOrCreateStakeEscrowInstruction; exports.getStakeEscrowEarningPerDay = getStakeEscrowEarningPerDay; exports.getStakeEscrowEarningPerDayAfterUnstake = getStakeEscrowEarningPerDayAfterUnstake; exports.getTokenBalances = getTokenBalances; exports.getTopStakerListStateEntryStakeAmount = getTopStakerListStateEntryStakeAmount; exports.getVirtualPrice = getVirtualPrice; exports.parseFeeVaultInfo = parseFeeVaultInfo; exports.parseTopStakerListState = parseTopStakerListState;
//# sourceMappingURL=index.js.map